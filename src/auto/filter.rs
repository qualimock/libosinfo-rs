// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../girs
// DO NOT EDIT

use crate::{ffi,Entity};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    ///
    ///
    /// # Implements
    ///
    /// [`FilterExt`][trait@crate::prelude::FilterExt]
    #[doc(alias = "OsinfoFilter")]
    pub struct Filter(Object<ffi::OsinfoFilter, ffi::OsinfoFilterClass>);

    match fn {
        type_ => || ffi::osinfo_filter_get_type(),
    }
}

impl Filter {
        pub const NONE: Option<&'static Filter> = None;
    

    /// Construct a new filter that matches all entities
    ///
    /// # Returns
    ///
    /// a filter object
    #[doc(alias = "osinfo_filter_new")]
    pub fn new() -> Filter {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::osinfo_filter_new())
        }
    }
}

impl Default for Filter {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

/// Trait containing all [`struct@Filter`] methods.
///
/// # Implementors
///
/// [`DeviceLinkFilter`][struct@crate::DeviceLinkFilter], [`Filter`][struct@crate::Filter], [`ProductFilter`][struct@crate::ProductFilter]
pub trait FilterExt: IsA<Filter> + 'static {
    /// Adds a constraint that requires the entity to have
    /// a property key `propName` with a value of `propVal`.
    /// If multiple constraints are added for the same
    /// `propName`, with different values, the entity have
    /// all property values.
    /// ## `propName`
    /// the name of the parameter key
    /// ## `propVal`
    /// the required property value
    #[doc(alias = "osinfo_filter_add_constraint")]
    fn add_constraint(&self, propName: &str, propVal: &str) {
        unsafe {
            ffi::osinfo_filter_add_constraint(self.as_ref().to_glib_none().0, propName.to_glib_none().0, propVal.to_glib_none().0);
        }
    }

    /// Remove all filter constraints for the matching property
    /// name.
    /// ## `propName`
    /// name of the key to remove constraints for
    #[doc(alias = "osinfo_filter_clear_constraint")]
    fn clear_constraint(&self, propName: &str) {
        unsafe {
            ffi::osinfo_filter_clear_constraint(self.as_ref().to_glib_none().0, propName.to_glib_none().0);
        }
    }

    /// Remove all filter property constraints
    #[doc(alias = "osinfo_filter_clear_constraints")]
    fn clear_constraints(&self) {
        unsafe {
            ffi::osinfo_filter_clear_constraints(self.as_ref().to_glib_none().0);
        }
    }

    /// Get a list of all constraint property keys
    ///
    /// # Returns
    ///
    /// List of constraint keys
    #[doc(alias = "osinfo_filter_get_constraint_keys")]
    #[doc(alias = "get_constraint_keys")]
    fn constraint_keys(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::osinfo_filter_get_constraint_keys(self.as_ref().to_glib_none().0))
        }
    }

    /// Get a list values for filter constraints with the named key
    /// ## `propName`
    /// the name of the key
    ///
    /// # Returns
    ///
    /// List of constraint values
    #[doc(alias = "osinfo_filter_get_constraint_values")]
    #[doc(alias = "get_constraint_values")]
    fn constraint_values(&self, propName: &str) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::osinfo_filter_get_constraint_values(self.as_ref().to_glib_none().0, propName.to_glib_none().0))
        }
    }

    /// Determine of an entity matches a filter
    /// ## `entity`
    /// an entity to query
    ///
    /// # Returns
    ///
    /// TRUE if entity passes the filter, FALSE otherwise
    #[doc(alias = "osinfo_filter_matches")]
    fn matches(&self, entity: &impl IsA<Entity>) -> bool {
        unsafe {
            from_glib(ffi::osinfo_filter_matches(self.as_ref().to_glib_none().0, entity.as_ref().to_glib_none().0))
        }
    }
}

impl<O: IsA<Filter>> FilterExt for O {}
