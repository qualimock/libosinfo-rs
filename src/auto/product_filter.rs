// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../girs
// DO NOT EDIT

use crate::{ffi,Filter,Product,ProductRelationship};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    ///
    ///
    /// # Implements
    ///
    /// [`ProductFilterExt`][trait@crate::prelude::ProductFilterExt], [`FilterExt`][trait@crate::prelude::FilterExt]
    #[doc(alias = "OsinfoProductFilter")]
    pub struct ProductFilter(Object<ffi::OsinfoProductFilter, ffi::OsinfoProductFilterClass>) @extends Filter;

    match fn {
        type_ => || ffi::osinfo_productfilter_get_type(),
    }
}

impl ProductFilter {
        pub const NONE: Option<&'static ProductFilter> = None;
    

    /// Construct a new filter that matches all operating
    /// systems
    ///
    /// # Returns
    ///
    /// a new filter
    #[doc(alias = "osinfo_productfilter_new")]
    pub fn new() -> ProductFilter {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::osinfo_productfilter_new())
        }
    }
}

impl Default for ProductFilter {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

/// Trait containing all [`struct@ProductFilter`] methods.
///
/// # Implementors
///
/// [`ProductFilter`][struct@crate::ProductFilter]
pub trait ProductFilterExt: IsA<ProductFilter> + 'static {
    /// Adds a constraint that matches products which
    /// have a relationship `relshp` with `product`. Multiple constraints
    /// can be set for the same `relshp` or `product`, in which case
    /// all must match
    /// ## `relshp`
    /// the relationship to filter on
    /// ## `product`
    /// the target product to filter on
    #[doc(alias = "osinfo_productfilter_add_product_constraint")]
    fn add_product_constraint(&self, relshp: ProductRelationship, product: &impl IsA<Product>) -> i32 {
        unsafe {
            ffi::osinfo_productfilter_add_product_constraint(self.as_ref().to_glib_none().0, relshp.into_glib(), product.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "osinfo_productfilter_add_support_date_constraint")]
    fn add_support_date_constraint(&self, when: &mut glib::Date) {
        unsafe {
            ffi::osinfo_productfilter_add_support_date_constraint(self.as_ref().to_glib_none().0, when.to_glib_none_mut().0);
        }
    }

    /// Remove all constraints for the relationship `relshp`
    /// ## `relshp`
    /// the relationship to clear
    #[doc(alias = "osinfo_productfilter_clear_product_constraint")]
    fn clear_product_constraint(&self, relshp: ProductRelationship) {
        unsafe {
            ffi::osinfo_productfilter_clear_product_constraint(self.as_ref().to_glib_none().0, relshp.into_glib());
        }
    }

    /// Remove all relationship constraints
    #[doc(alias = "osinfo_productfilter_clear_product_constraints")]
    fn clear_product_constraints(&self) {
        unsafe {
            ffi::osinfo_productfilter_clear_product_constraints(self.as_ref().to_glib_none().0);
        }
    }

    /// Retrieve a list of all operating systems that are
    /// the target of constraint for the relationship
    /// `relshp`.
    /// ## `relshp`
    /// a relationship to query
    ///
    /// # Returns
    ///
    /// a list of operating systems
    #[doc(alias = "osinfo_productfilter_get_product_constraint_values")]
    #[doc(alias = "get_product_constraint_values")]
    fn product_constraint_values(&self, relshp: ProductRelationship) -> Vec<Product> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::osinfo_productfilter_get_product_constraint_values(self.as_ref().to_glib_none().0, relshp.into_glib()))
        }
    }
}

impl<O: IsA<ProductFilter>> ProductFilterExt for O {}
