// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../girs
// DO NOT EDIT

use crate::{ffi,Db};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    ///
    ///
    /// # Implements
    ///
    /// [`LoaderExt`][trait@crate::prelude::LoaderExt]
    #[doc(alias = "OsinfoLoader")]
    pub struct Loader(Object<ffi::OsinfoLoader, ffi::OsinfoLoaderClass>);

    match fn {
        type_ => || ffi::osinfo_loader_get_type(),
    }
}

impl Loader {
        pub const NONE: Option<&'static Loader> = None;
    

    /// Create a new database loader
    ///
    /// # Returns
    ///
    /// a loader object
    #[doc(alias = "osinfo_loader_new")]
    pub fn new() -> Loader {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::osinfo_loader_new())
        }
    }
}

impl Default for Loader {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

/// Trait containing all [`struct@Loader`] methods.
///
/// # Implementors
///
/// [`Loader`][struct@crate::Loader]
pub trait LoaderExt: IsA<Loader> + 'static {
    /// Retrieves the database being populated
    ///
    /// # Returns
    ///
    /// the database
    #[doc(alias = "osinfo_loader_get_db")]
    #[doc(alias = "get_db")]
    fn db(&self) -> Option<Db> {
        unsafe {
            from_glib_none(ffi::osinfo_loader_get_db(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "osinfo_loader_process_default_path")]
    fn process_default_path(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let _ = ffi::osinfo_loader_process_default_path(self.as_ref().to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Loads data from the local path.
    #[doc(alias = "osinfo_loader_process_local_path")]
    fn process_local_path(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let _ = ffi::osinfo_loader_process_local_path(self.as_ref().to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Loads data from the specified path. If the path
    /// points to a file, that will be loaded as XML
    /// Otherwise it can point to a directory which will
    /// be recursively traversed, loading all files as XML.
    /// ## `path`
    /// the fully qualified path
    #[doc(alias = "osinfo_loader_process_path")]
    fn process_path(&self, path: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let _ = ffi::osinfo_loader_process_path(self.as_ref().to_glib_none().0, path.to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Loads data from the system path.
    #[doc(alias = "osinfo_loader_process_system_path")]
    fn process_system_path(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let _ = ffi::osinfo_loader_process_system_path(self.as_ref().to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Loads data from the specified URI. If the URI
    /// points to a file, that will be loaded as XML
    /// Otherwise it can point to a directory which will
    /// be recursively traversed, loading all files as XML.
    /// ## `uri`
    /// the data source URI
    #[doc(alias = "osinfo_loader_process_uri")]
    fn process_uri(&self, uri: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let _ = ffi::osinfo_loader_process_uri(self.as_ref().to_glib_none().0, uri.to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Loads data from user path.
    #[doc(alias = "osinfo_loader_process_user_path")]
    fn process_user_path(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let _ = ffi::osinfo_loader_process_user_path(self.as_ref().to_glib_none().0, &mut error);
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }
}

impl<O: IsA<Loader>> LoaderExt for O {}
