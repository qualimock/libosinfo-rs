// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../girs
// DO NOT EDIT

use crate::{ffi,Entity};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    ///
    ///
    /// # Implements
    ///
    /// [`InstallConfigExt`][trait@crate::prelude::InstallConfigExt], [`EntityExt`][trait@crate::prelude::EntityExt]
    #[doc(alias = "OsinfoInstallConfig")]
    pub struct InstallConfig(Object<ffi::OsinfoInstallConfig, ffi::OsinfoInstallConfigClass>) @extends Entity;

    match fn {
        type_ => || ffi::osinfo_install_config_get_type(),
    }
}

impl InstallConfig {
        pub const NONE: Option<&'static InstallConfig> = None;
    

    /// Construct a new install configuration with default values for
    /// language, keyboard, timezone and admin password. The default values
    /// are to use an 'en_US' language and keyboard, and an 'America/New_York'
    /// timezone. The admin password is set to a random 8 character password.
    /// ## `id`
    /// the unique identifier
    ///
    /// # Returns
    ///
    /// an install configuration with default
    /// values
    #[doc(alias = "osinfo_install_config_new")]
    pub fn new(id: &str) -> InstallConfig {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::osinfo_install_config_new(id.to_glib_none().0))
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`InstallConfig`] objects.
            ///
            /// This method returns an instance of [`InstallConfigBuilder`](crate::builders::InstallConfigBuilder) which can be used to create [`InstallConfig`] objects.
            pub fn builder() -> InstallConfigBuilder {
                InstallConfigBuilder::new()
            }
        
}

impl Default for InstallConfig {
                     fn default() -> Self {
                         glib::object::Object::new::<Self>()
                     }
                 }

// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`InstallConfig`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct InstallConfigBuilder {
            builder: glib::object::ObjectBuilder<'static, InstallConfig>,
        }

        impl InstallConfigBuilder {
        fn new() -> Self {
            Self { builder: glib::object::Object::builder() }
        }

                            /// The unique identifier for the entity The format of identifiers
                            /// is undefined, but the recommended practice is to use a URI.
                            /// This parameter must be set at time of construction as no
                            /// default value is provided.
                            pub fn id(self, id: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("id", id.into()), }
                        }

    // rustdoc-stripper-ignore-next
    /// Build the [`InstallConfig`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> InstallConfig {
assert_initialized_main_thread!();
    self.builder.build() }
}

/// Trait containing all [`struct@InstallConfig`] methods.
///
/// # Implementors
///
/// [`InstallConfig`][struct@crate::InstallConfig]
pub trait InstallConfigExt: IsA<InstallConfig> + 'static {
    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_ADMIN_PASSWORD` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_admin_password")]
    #[doc(alias = "get_admin_password")]
    fn admin_password(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_admin_password(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_AVATAR_DISK` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_avatar_disk")]
    #[doc(alias = "get_avatar_disk")]
    fn avatar_disk(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_avatar_disk(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_AVATAR_LOCATION` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_avatar_location")]
    #[doc(alias = "get_avatar_location")]
    fn avatar_location(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_avatar_location(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if driver signing is currently enabled, [`false`] otherwise, see
    /// [`set_driver_signing()`][Self::set_driver_signing()] for more details about driver
    /// signing.
    #[doc(alias = "osinfo_install_config_get_driver_signing")]
    #[doc(alias = "get_driver_signing")]
    fn is_driver_signing(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_install_config_get_driver_signing(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_HARDWARE_ARCH` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_hardware_arch")]
    #[doc(alias = "get_hardware_arch")]
    fn hardware_arch(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_hardware_arch(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_HOSTNAME` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_hostname")]
    #[doc(alias = "get_hostname")]
    fn hostname(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_hostname(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns the URL the script will use to perform the installation.
    #[cfg(feature = "v1_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_5")))]
    #[doc(alias = "osinfo_install_config_get_installation_url")]
    #[doc(alias = "get_installation_url")]
    fn installation_url(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_installation_url(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_L10N_KEYBOARD` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_l10n_keyboard")]
    #[doc(alias = "get_l10n_keyboard")]
    fn l10n_keyboard(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_l10n_keyboard(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_L10N_LANGUAGE` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_l10n_language")]
    #[doc(alias = "get_l10n_language")]
    fn l10n_language(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_l10n_language(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_L10N_TIMEZONE` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_l10n_timezone")]
    #[doc(alias = "get_l10n_timezone")]
    fn l10n_timezone(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_l10n_timezone(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The disk on which post-installation drivers are located, or NULL if
    /// its not set using [`set_post_install_drivers_disk()`][Self::set_post_install_drivers_disk()].
    #[doc(alias = "osinfo_install_config_get_post_install_drivers_disk")]
    #[doc(alias = "get_post_install_drivers_disk")]
    fn post_install_drivers_disk(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_post_install_drivers_disk(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The disk on which post-installation drivers are located, or NULL if
    /// its not set using [`set_post_install_drivers_location()`][Self::set_post_install_drivers_location()].
    #[doc(alias = "osinfo_install_config_get_post_install_drivers_location")]
    #[doc(alias = "get_post_install_drivers_location")]
    fn post_install_drivers_location(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_post_install_drivers_location(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The disk on which pre-installation drivers are located, or NULL if
    /// its not set using [`set_pre_install_drivers_disk()`][Self::set_pre_install_drivers_disk()].
    #[doc(alias = "osinfo_install_config_get_pre_install_drivers_disk")]
    #[doc(alias = "get_pre_install_drivers_disk")]
    fn pre_install_drivers_disk(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_pre_install_drivers_disk(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The location on which pre-installation drivers are located, or NULL if
    /// its not set using [`set_pre_install_drivers_location()`][Self::set_pre_install_drivers_location()].
    #[doc(alias = "osinfo_install_config_get_pre_install_drivers_location")]
    #[doc(alias = "get_pre_install_drivers_location")]
    fn pre_install_drivers_location(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_pre_install_drivers_location(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_REG_LOGIN` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_reg_login")]
    #[doc(alias = "get_reg_login")]
    fn reg_login(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_reg_login(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_REG_PASSWORD` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_reg_password")]
    #[doc(alias = "get_reg_password")]
    fn reg_password(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_reg_password(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_REG_PRODUCTKEY` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_reg_product_key")]
    #[doc(alias = "get_reg_product_key")]
    fn reg_product_key(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_reg_product_key(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_SCRIPT_DISK` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_script_disk")]
    #[doc(alias = "get_script_disk")]
    fn script_disk(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_script_disk(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_TARGET_DISK` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_target_disk")]
    #[doc(alias = "get_target_disk")]
    fn target_disk(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_target_disk(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_USER_ADMIN` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_user_administrator")]
    #[doc(alias = "get_user_administrator")]
    fn is_user_administrator(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_install_config_get_user_administrator(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_USER_AUTOLOGIN` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_user_autologin")]
    #[doc(alias = "get_user_autologin")]
    fn is_user_autologin(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_install_config_get_user_autologin(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_USER_LOGIN` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_user_login")]
    #[doc(alias = "get_user_login")]
    fn user_login(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_user_login(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_USER_PASSWORD` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_user_password")]
    #[doc(alias = "get_user_password")]
    fn user_password(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_user_password(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The value of `OSINFO_INSTALL_CONFIG_PROP_USER_REALNAME` parameter,
    ///  or NULL.
    #[doc(alias = "osinfo_install_config_get_user_realname")]
    #[doc(alias = "get_user_realname")]
    fn user_realname(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_install_config_get_user_realname(self.as_ref().to_glib_none().0))
        }
    }

    /// Sets the `OSINFO_INSTALL_CONFIG_PROP_ADMIN_PASSWORD` parameter
    /// ## `password`
    /// the administrator password to be set
    #[doc(alias = "osinfo_install_config_set_admin_password")]
    fn set_admin_password(&self, password: &str) {
        unsafe {
            ffi::osinfo_install_config_set_admin_password(self.as_ref().to_glib_none().0, password.to_glib_none().0);
        }
    }

    /// Sets the `OSINFO_INSTALL_CONFIG_PROP_AVATAR_DISK` parameter.
    ///
    /// Please read documentation on [`set_target_disk()`][Self::set_target_disk()] for
    /// explanation on the format of `disk` string.
    /// ## `disk`
    /// the avatar disk
    #[doc(alias = "osinfo_install_config_set_avatar_disk")]
    fn set_avatar_disk(&self, disk: &str) {
        unsafe {
            ffi::osinfo_install_config_set_avatar_disk(self.as_ref().to_glib_none().0, disk.to_glib_none().0);
        }
    }

    /// Sets the `OSINFO_INSTALL_CONFIG_PROP_AVATAR_LOCATION` parameter.
    ///
    /// Note that the format of this string is dependent on the installer script
    /// `self` is going to be used with. You can use
    /// [`InstallScriptExt::path_format()`][crate::prelude::InstallScriptExt::path_format()] to find out which format
    /// does the script expects this string to be in.
    ///
    /// Also note that in case of [`PathFormat::Dos`][crate::PathFormat::Dos], the drive/disk letter
    /// and the leading ':' must not be included in the path.
    /// ## `location`
    /// new location
    #[doc(alias = "osinfo_install_config_set_avatar_location")]
    fn set_avatar_location(&self, location: &str) {
        unsafe {
            ffi::osinfo_install_config_set_avatar_location(self.as_ref().to_glib_none().0, location.to_glib_none().0);
        }
    }

    /// If a script requires drivers to be signed, this function can be used to
    /// disable that security feature. WARNING: Disabling driver signing may very
    /// well mean disabling it permanently.
    /// ## `signing`
    /// boolean value
    #[doc(alias = "osinfo_install_config_set_driver_signing")]
    fn set_driver_signing(&self, signing: bool) {
        unsafe {
            ffi::osinfo_install_config_set_driver_signing(self.as_ref().to_glib_none().0, signing.into_glib());
        }
    }

    /// Sets the `OSINFO_INSTALL_CONFIG_PROP_HARDWARE_ARCH` parameter.
    ///
    /// The list of valid architectures are part of osinfo.rng schema
    /// ## `arch`
    /// the hardware architecture
    #[doc(alias = "osinfo_install_config_set_hardware_arch")]
    fn set_hardware_arch(&self, arch: &str) {
        unsafe {
            ffi::osinfo_install_config_set_hardware_arch(self.as_ref().to_glib_none().0, arch.to_glib_none().0);
        }
    }

    /// Sets the `OSINFO_INSTALL_CONFIG_PROP_HOSTNAME` parameter.
    ///
    /// Note that some operating systems have restrictions on maximum number of, and
    /// allowed characters in hostname (or its equivalent) so it is highly
    /// recommended that you keep the actual hostname less than or equal to 15
    /// characters long and make sure that it does not contain any characters other
    /// than ASCII alphanumeric and '-'. Otherwise unattended installation might
    /// fail.
    /// ## `hostname`
    /// the desired hostname
    #[doc(alias = "osinfo_install_config_set_hostname")]
    fn set_hostname(&self, hostname: &str) {
        unsafe {
            ffi::osinfo_install_config_set_hostname(self.as_ref().to_glib_none().0, hostname.to_glib_none().0);
        }
    }

    /// When performing a tree based installation the script will need the installation
    /// URL to be set, whenever the installation is performed from a non canonical place.
    /// ## `url`
    /// the URL used to perform the installation
    #[cfg(feature = "v1_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_5")))]
    #[doc(alias = "osinfo_install_config_set_installation_url")]
    fn set_installation_url(&self, url: &str) {
        unsafe {
            ffi::osinfo_install_config_set_installation_url(self.as_ref().to_glib_none().0, url.to_glib_none().0);
        }
    }

    /// Sets the `OSINFO_INSTALL_CONFIG_PROP_L10N_KEYBOARD` parameter.
    ///
    /// The expected format of this string is the same as
    /// `osinfo_install_config_set_l10n_language` function's 'language' parameter.
    /// ## `keyboard`
    /// the keyboard
    #[doc(alias = "osinfo_install_config_set_l10n_keyboard")]
    fn set_l10n_keyboard(&self, keyboard: &str) {
        unsafe {
            ffi::osinfo_install_config_set_l10n_keyboard(self.as_ref().to_glib_none().0, keyboard.to_glib_none().0);
        }
    }

    /// Sets the `OSINFO_INSTALL_CONFIG_PROP_L10N_LANGUAGE` parameter.
    ///
    /// The expected format of this string is the gettext locale names standard:
    ///
    /// https://www.gnu.org/savannah-checkouts/gnu/gettext/manual/html_node/Locale-Names.html
    ///
    /// Encoding and variant are (at least for now) not supported. For example,
    /// 'pt_BR' is accepted is accepted as the language codes for Brazilian Portuguese
    /// but 'pt_BR.utf8' is not.
    /// ## `language`
    /// the language
    #[doc(alias = "osinfo_install_config_set_l10n_language")]
    fn set_l10n_language(&self, language: &str) {
        unsafe {
            ffi::osinfo_install_config_set_l10n_language(self.as_ref().to_glib_none().0, language.to_glib_none().0);
        }
    }

    /// Set the `OSINFO_INSTALL_CONFIG_PROP_L10N_TIMEZONE` parameter.
    ///
    /// The expected format of this string is the tzdata names standard.
    /// ## `tz`
    /// the timezone
    #[doc(alias = "osinfo_install_config_set_l10n_timezone")]
    fn set_l10n_timezone(&self, tz: &str) {
        unsafe {
            ffi::osinfo_install_config_set_l10n_timezone(self.as_ref().to_glib_none().0, tz.to_glib_none().0);
        }
    }

    /// Specify the disk on which drivers to be installed at the end of installation,
    /// are available.
    ///
    /// Please read documentation on [`set_target_disk()`][Self::set_target_disk()] for
    /// explanation on the format of `disk` string.
    ///
    /// NOTE: Not every install script supports post-installation of drivers. Use
    /// [`InstallScriptExt::can_post_install_drivers()`][crate::prelude::InstallScriptExt::can_post_install_drivers()] to find out if an
    /// install script supports it.
    /// ## `disk`
    /// the target disk
    #[doc(alias = "osinfo_install_config_set_post_install_drivers_disk")]
    fn set_post_install_drivers_disk(&self, disk: &str) {
        unsafe {
            ffi::osinfo_install_config_set_post_install_drivers_disk(self.as_ref().to_glib_none().0, disk.to_glib_none().0);
        }
    }

    /// Specify the disk on which drivers to be installed at the end of installation,
    /// are available.
    ///
    /// Please read documentation on [`set_avatar_location()`][Self::set_avatar_location()] for
    /// explanation on the format of `location` string.
    ///
    /// NOTE: Not every install script supports post-installation of drivers. Use
    /// [`InstallScriptExt::can_post_install_drivers()`][crate::prelude::InstallScriptExt::can_post_install_drivers()] to find out if an
    /// install script supports it.
    /// ## `location`
    /// the location of avatar
    #[doc(alias = "osinfo_install_config_set_post_install_drivers_location")]
    fn set_post_install_drivers_location(&self, location: &str) {
        unsafe {
            ffi::osinfo_install_config_set_post_install_drivers_location(self.as_ref().to_glib_none().0, location.to_glib_none().0);
        }
    }

    /// Specify the disk on which drivers to be installed at the very beginning of
    /// installation, are available. This is usually needed for devices for which the
    /// OS in question does not have out of the box support for and devices are
    /// required/preferred to be available during actual installation.
    ///
    /// Please read documentation on [`set_target_disk()`][Self::set_target_disk()] for
    /// explanation on the format of `disk` string.
    ///
    /// NOTE: Not every install script supports pre-installation of drivers. Use
    /// [`InstallScriptExt::can_pre_install_drivers()`][crate::prelude::InstallScriptExt::can_pre_install_drivers()] to find out if an
    /// installer script supports it.
    ///
    /// NOTE: Microsoft Windows XP requires pre-installation driver files to be
    /// present in the script disk under the toplevel directory.
    /// ## `disk`
    /// the disk
    #[doc(alias = "osinfo_install_config_set_pre_install_drivers_disk")]
    fn set_pre_install_drivers_disk(&self, disk: &str) {
        unsafe {
            ffi::osinfo_install_config_set_pre_install_drivers_disk(self.as_ref().to_glib_none().0, disk.to_glib_none().0);
        }
    }

    /// Specify the location on which drivers to be installed at the very beginning of
    /// installation, are available. Please read documentation on
    /// [`set_pre_install_drivers_disk()`][Self::set_pre_install_drivers_disk()] for more information
    /// about pre-installation of drivers.
    ///
    /// Please read documentation on [`set_avatar_location()`][Self::set_avatar_location()] for
    /// explanation on the format of `location` string.
    /// ## `location`
    /// the location
    #[doc(alias = "osinfo_install_config_set_pre_install_drivers_location")]
    fn set_pre_install_drivers_location(&self, location: &str) {
        unsafe {
            ffi::osinfo_install_config_set_pre_install_drivers_location(self.as_ref().to_glib_none().0, location.to_glib_none().0);
        }
    }

    /// Sets the value of `OSINFO_INSTALL_CONFIG_PROP_REG_LOGIN` parameter.
    /// ## `name`
    /// the registration login
    #[doc(alias = "osinfo_install_config_set_reg_login")]
    fn set_reg_login(&self, name: &str) {
        unsafe {
            ffi::osinfo_install_config_set_reg_login(self.as_ref().to_glib_none().0, name.to_glib_none().0);
        }
    }

    /// Sets the value of `OSINFO_INSTALL_CONFIG_PROP_REG_PASSWORD` parameter.
    /// ## `password`
    /// the registration password
    #[doc(alias = "osinfo_install_config_set_reg_password")]
    fn set_reg_password(&self, password: &str) {
        unsafe {
            ffi::osinfo_install_config_set_reg_password(self.as_ref().to_glib_none().0, password.to_glib_none().0);
        }
    }

    #[doc(alias = "osinfo_install_config_set_reg_product_key")]
    fn set_reg_product_key(&self, key: &str) {
        unsafe {
            ffi::osinfo_install_config_set_reg_product_key(self.as_ref().to_glib_none().0, key.to_glib_none().0);
        }
    }

    /// Sets the `OSINFO_INSTALL_CONFIG_PROP_SCRIPT_DISK` parameter.
    ///
    /// Please read documentation on [`set_target_disk()`][Self::set_target_disk()] for
    /// explanation on the format of `disk` string.
    /// ## `disk`
    /// the disk
    #[doc(alias = "osinfo_install_config_set_script_disk")]
    fn set_script_disk(&self, disk: &str) {
        unsafe {
            ffi::osinfo_install_config_set_script_disk(self.as_ref().to_glib_none().0, disk.to_glib_none().0);
        }
    }

    /// Sets the `OSINFO_INSTALL_CONFIG_PROP_TARGET_DISK` parameter.
    ///
    /// Note that the format of this string is dependent on the installer script
    /// `self` is going to be used with. You can use
    /// [`InstallScriptExt::path_format()`][crate::prelude::InstallScriptExt::path_format()] to find out which format
    /// does the script expects this string to be in. In case of
    /// [`PathFormat::Unix`][crate::PathFormat::Unix] unix device node names are expected, e.g "/dev/fd0".
    /// In case of [`PathFormat::Dos`][crate::PathFormat::Dos] drive letters are expected, e.g "A".
    /// ## `disk`
    /// the target disk
    #[doc(alias = "osinfo_install_config_set_target_disk")]
    fn set_target_disk(&self, disk: &str) {
        unsafe {
            ffi::osinfo_install_config_set_target_disk(self.as_ref().to_glib_none().0, disk.to_glib_none().0);
        }
    }

    /// Sets the value of `OSINFO_INSTALL_CONFIG_PROP_USER_ADMIN` parameter.
    /// ## `admin`
    /// whether the user should be set as administrator or not
    #[doc(alias = "osinfo_install_config_set_user_administrator")]
    fn set_user_administrator(&self, admin: bool) {
        unsafe {
            ffi::osinfo_install_config_set_user_administrator(self.as_ref().to_glib_none().0, admin.into_glib());
        }
    }

    /// Sets the value of `OSINFO_INSTALL_CONFIG_PROP_USER_AUTOLOGIN` parameter.
    /// ## `autologin`
    /// whether autologin should be set for the user or not
    #[doc(alias = "osinfo_install_config_set_user_autologin")]
    fn set_user_autologin(&self, autologin: bool) {
        unsafe {
            ffi::osinfo_install_config_set_user_autologin(self.as_ref().to_glib_none().0, autologin.into_glib());
        }
    }

    /// Sets the value of `OSINFO_INSTALL_CONFIG_PROP_USER_LOGIN` parameter.
    /// ## `username`
    /// the chosen username for the user log into the system
    #[doc(alias = "osinfo_install_config_set_user_login")]
    fn set_user_login(&self, username: &str) {
        unsafe {
            ffi::osinfo_install_config_set_user_login(self.as_ref().to_glib_none().0, username.to_glib_none().0);
        }
    }

    /// Sets the `OSINFO_INSTALL_CONFIG_PROP_USER_PASSWORD` parameter
    /// ## `password`
    /// the user password to be set
    #[doc(alias = "osinfo_install_config_set_user_password")]
    fn set_user_password(&self, password: &str) {
        unsafe {
            ffi::osinfo_install_config_set_user_password(self.as_ref().to_glib_none().0, password.to_glib_none().0);
        }
    }

    /// Sets the value of `OSINFO_INSTALL_CONFIG_PROP_USER_REALNAME` parameter.
    /// ## `name`
    /// the user real name to be displayed
    #[doc(alias = "osinfo_install_config_set_user_realname")]
    fn set_user_realname(&self, name: &str) {
        unsafe {
            ffi::osinfo_install_config_set_user_realname(self.as_ref().to_glib_none().0, name.to_glib_none().0);
        }
    }
}

impl<O: IsA<InstallConfig>> InstallConfigExt for O {}
