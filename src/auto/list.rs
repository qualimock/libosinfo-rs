// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../girs
// DO NOT EDIT

use crate::{ffi,Entity,Filter};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    ///
    ///
    /// This is an Abstract Base Class, you cannot instantiate it.
    ///
    /// ## Properties
    ///
    ///
    /// #### `element-type`
    ///  The specialization of the list. The list will be
    /// restricted to storing [`Entity`][crate::Entity] objects of
    /// the specified type.
    ///
    /// Readable | Writeable | Construct Only
    ///
    /// # Implements
    ///
    /// [`ListExt`][trait@crate::prelude::ListExt]
    #[doc(alias = "OsinfoList")]
    pub struct List(Object<ffi::OsinfoList, ffi::OsinfoListClass>);

    match fn {
        type_ => || ffi::osinfo_list_get_type(),
    }
}

impl List {
        pub const NONE: Option<&'static List> = None;
    
}

/// Trait containing all [`struct@List`] methods.
///
/// # Implementors
///
/// [`DatamapList`][struct@crate::DatamapList], [`DeploymentList`][struct@crate::DeploymentList], [`DeviceDriverList`][struct@crate::DeviceDriverList], [`DeviceLinkList`][struct@crate::DeviceLinkList], [`DeviceList`][struct@crate::DeviceList], [`FirmwareList`][struct@crate::FirmwareList], [`ImageList`][struct@crate::ImageList], [`InstallConfigParamList`][struct@crate::InstallConfigParamList], [`InstallScriptList`][struct@crate::InstallScriptList], [`List`][struct@crate::List], [`MediaList`][struct@crate::MediaList], [`OsVariantList`][struct@crate::OsVariantList], [`ProductList`][struct@crate::ProductList], [`ResourcesList`][struct@crate::ResourcesList], [`TreeList`][struct@crate::TreeList]
pub trait ListExt: IsA<List> + 'static {
    /// Adds a new entity to the list.
    /// ## `entity`
    /// the entity to add to the list
    #[doc(alias = "osinfo_list_add")]
    fn add(&self, entity: &impl IsA<Entity>) {
        unsafe {
            ffi::osinfo_list_add(self.as_ref().to_glib_none().0, entity.as_ref().to_glib_none().0);
        }
    }

    /// Adds all entities from `source` to `self`. Using one
    /// of the constructors in a subclass is preferable
    /// to this method.
    /// ## `source`
    /// the list to add
    #[doc(alias = "osinfo_list_add_all")]
    fn add_all(&self, source: &impl IsA<List>) {
        unsafe {
            ffi::osinfo_list_add_all(self.as_ref().to_glib_none().0, source.as_ref().to_glib_none().0);
        }
    }

    /// Adds all entities from `source` which are matched by `filter`. Using one
    /// of the constructors in a subclass is preferable
    /// to this method.
    /// ## `source`
    /// the source for elements
    /// ## `filter`
    /// filter to process the source with
    #[doc(alias = "osinfo_list_add_filtered")]
    fn add_filtered(&self, source: &impl IsA<List>, filter: &impl IsA<Filter>) {
        unsafe {
            ffi::osinfo_list_add_filtered(self.as_ref().to_glib_none().0, source.as_ref().to_glib_none().0, filter.as_ref().to_glib_none().0);
        }
    }

    /// Computes the intersection between `sourceOne` and `sourceTwo` and
    /// adds the resulting list of entities to the `self`. Using one
    /// of the constructors in a subclass is preferable
    /// to this method.
    /// ## `sourceOne`
    /// the first list to add
    /// ## `sourceTwo`
    /// the second list to add
    #[doc(alias = "osinfo_list_add_intersection")]
    fn add_intersection(&self, sourceOne: &impl IsA<List>, sourceTwo: &impl IsA<List>) {
        unsafe {
            ffi::osinfo_list_add_intersection(self.as_ref().to_glib_none().0, sourceOne.as_ref().to_glib_none().0, sourceTwo.as_ref().to_glib_none().0);
        }
    }

    /// Computes the union between `sourceOne` and `sourceTwo` and
    /// adds the resulting list of entities to the `self`. Using one
    /// of the constructors in a subclass is preferable
    /// to this method.
    /// ## `sourceOne`
    /// the first list to add
    /// ## `sourceTwo`
    /// the second list to add
    #[doc(alias = "osinfo_list_add_union")]
    fn add_union(&self, sourceOne: &impl IsA<List>, sourceTwo: &impl IsA<List>) {
        unsafe {
            ffi::osinfo_list_add_union(self.as_ref().to_glib_none().0, sourceOne.as_ref().to_glib_none().0, sourceTwo.as_ref().to_glib_none().0);
        }
    }

    /// Search the list looking for the entity with a matching
    /// unique identifier.
    /// ## `id`
    /// the unique identifier
    ///
    /// # Returns
    ///
    /// the matching entity, or NULL
    #[doc(alias = "osinfo_list_find_by_id")]
    fn find_by_id(&self, id: &str) -> Option<Entity> {
        unsafe {
            from_glib_none(ffi::osinfo_list_find_by_id(self.as_ref().to_glib_none().0, id.to_glib_none().0))
        }
    }

    /// Retrieves the type of the subclass of [`Entity`][crate::Entity]
    /// that may be stored in the list
    ///
    /// # Returns
    ///
    /// the type of entity stored
    #[doc(alias = "osinfo_list_get_element_type")]
    #[doc(alias = "get_element_type")]
    #[doc(alias = "element-type")]
    fn element_type(&self) -> glib::types::Type {
        unsafe {
            from_glib(ffi::osinfo_list_get_element_type(self.as_ref().to_glib_none().0))
        }
    }

    /// Retrieve a linked list of all elements in the list.
    ///
    /// # Returns
    ///
    /// the list elements
    #[doc(alias = "osinfo_list_get_elements")]
    #[doc(alias = "get_elements")]
    fn elements(&self) -> Vec<Entity> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::osinfo_list_get_elements(self.as_ref().to_glib_none().0))
        }
    }

    /// Retrieves the number of elements currently stored
    /// in the list
    ///
    /// # Returns
    ///
    /// the list length
    #[doc(alias = "osinfo_list_get_length")]
    #[doc(alias = "get_length")]
    fn length(&self) -> i32 {
        unsafe {
            ffi::osinfo_list_get_length(self.as_ref().to_glib_none().0)
        }
    }

    /// Retrieves the element in the list at position `idx`. If
    /// `idx` is less than zero, or greater than the number of
    /// elements in the list, the results are undefined.
    /// ## `idx`
    /// the list position to fetch
    ///
    /// # Returns
    ///
    /// the list element or [`None`]
    #[doc(alias = "osinfo_list_get_nth")]
    #[doc(alias = "get_nth")]
    fn nth(&self, idx: i32) -> Option<Entity> {
        unsafe {
            from_glib_none(ffi::osinfo_list_get_nth(self.as_ref().to_glib_none().0, idx))
        }
    }

    #[doc(alias = "osinfo_list_new_copy")]
#[must_use]
    fn new_copy(&self) -> Option<List> {
        unsafe {
            from_glib_full(ffi::osinfo_list_new_copy(self.as_ref().to_glib_none().0))
        }
    }

    /// Construct a new list that is filled with elements from `self` that
    /// match `filter`
    /// ## `filter`
    /// the filter to apply
    ///
    /// # Returns
    ///
    /// a filtered copy of the list
    #[doc(alias = "osinfo_list_new_filtered")]
#[must_use]
    fn new_filtered(&self, filter: &impl IsA<Filter>) -> Option<List> {
        unsafe {
            from_glib_full(ffi::osinfo_list_new_filtered(self.as_ref().to_glib_none().0, filter.as_ref().to_glib_none().0))
        }
    }

    /// Construct a new list that is filled with only the elements
    /// that are present in both `self` and `sourceTwo`.
    /// ## `sourceTwo`
    /// the second list to copy
    ///
    /// # Returns
    ///
    /// an intersection of the two lists
    #[doc(alias = "osinfo_list_new_intersection")]
#[must_use]
    fn new_intersection(&self, sourceTwo: &impl IsA<List>) -> Option<List> {
        unsafe {
            from_glib_full(ffi::osinfo_list_new_intersection(self.as_ref().to_glib_none().0, sourceTwo.as_ref().to_glib_none().0))
        }
    }

    /// Construct a new list that is filled with all the that are present in
    /// either `self` and `sourceTwo`. `self` and `sourceTwo` must be of
    /// the same type.
    /// ## `sourceTwo`
    /// the second list to copy
    ///
    /// # Returns
    ///
    /// a union of the two lists
    #[doc(alias = "osinfo_list_new_union")]
#[must_use]
    fn new_union(&self, sourceTwo: &impl IsA<List>) -> Option<List> {
        unsafe {
            from_glib_full(ffi::osinfo_list_new_union(self.as_ref().to_glib_none().0, sourceTwo.as_ref().to_glib_none().0))
        }
    }
}

impl<O: IsA<List>> ListExt for O {}
