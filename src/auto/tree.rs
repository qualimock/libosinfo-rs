// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../girs
// DO NOT EDIT

use crate::{ffi,Entity,Os};
#[cfg(feature = "v1_5")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_5")))]
use crate::{OsVariantList};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_,pin::Pin};

glib::wrapper! {
    ///
    ///
    /// ## Properties
    ///
    ///
    /// #### `architecture`
    ///  The target hardware architecture of this tree.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `boot-iso-path`
    ///  The path to the boot ISO in the install tree
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `has-treeinfo`
    ///  Whether the tree has treeinfo or not
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `initrd-path`
    ///  The path to the initrd image in the install tree.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `kernel-path`
    ///  The path to the kernel image in the install tree.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `os`
    ///  Os information for the current tree. For tree stored in an
    /// [`Db`][crate::Db], it will be filled when the database is loaded, otherwise
    /// the property will be filled after a successful call to
    /// [`DbExt::identify_tree()`][crate::prelude::DbExt::identify_tree()].
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `treeinfo-arch`
    ///  The treeinfo arch
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `treeinfo-family`
    ///  The treeinfo family
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `treeinfo-variant`
    ///  The treeinfo variant
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `treeinfo-version`
    ///  The treeinfo version
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `url`
    ///  The URL to this tree.
    ///
    /// Readable | Writeable
    /// <details><summary><h4>Entity</h4></summary>
    ///
    ///
    /// #### `id`
    ///  The unique identifier for the entity The format of identifiers
    /// is undefined, but the recommended practice is to use a URI.
    /// This parameter must be set at time of construction as no
    /// default value is provided.
    ///
    /// Readable | Writeable | Construct
    /// </details>
    ///
    /// # Implements
    ///
    /// [`TreeExt`][trait@crate::prelude::TreeExt], [`EntityExt`][trait@crate::prelude::EntityExt]
    #[doc(alias = "OsinfoTree")]
    pub struct Tree(Object<ffi::OsinfoTree, ffi::OsinfoTreeClass>) @extends Entity;

    match fn {
        type_ => || ffi::osinfo_tree_get_type(),
    }
}

impl Tree {
        pub const NONE: Option<&'static Tree> = None;
    

    /// Create a new tree entity
    /// ## `id`
    /// the id of the tree to be created
    /// ## `architecture`
    /// the architecture of the tree to be created
    ///
    /// # Returns
    ///
    /// A tree entity
    #[doc(alias = "osinfo_tree_new")]
    pub fn new(id: &str, architecture: &str) -> Tree {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::osinfo_tree_new(id.to_glib_none().0, architecture.to_glib_none().0))
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`Tree`] objects.
            ///
            /// This method returns an instance of [`TreeBuilder`](crate::builders::TreeBuilder) which can be used to create [`Tree`] objects.
            pub fn builder() -> TreeBuilder {
                TreeBuilder::new()
            }
        

    /// Creates a new [`Tree`][crate::Tree] for installation tree at `location`. The `location`
    /// could be a http:// or a https:// URI, or a local file.
    ///
    /// NOTE: Currently this only works for trees with a .treeinfo file
    /// ## `location`
    /// the location of an installation tree
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    ///
    /// # Returns
    ///
    /// a new [`Tree`][crate::Tree] , or NULL on error
    #[doc(alias = "osinfo_tree_create_from_location")]
    pub fn create_from_location(location: &str, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<Tree, glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::osinfo_tree_create_from_location(location.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    /// Asynchronous variant of `osinfo_tree_create_from_location`.
    /// ## `location`
    /// the location of an installation tree
    /// ## `priority`
    /// the I/O priority of the request
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    /// ## `callback`
    /// Function to call when result of this call is ready
    #[doc(alias = "osinfo_tree_create_from_location_async")]
    pub fn create_from_location_async<P: FnOnce(Result<Tree, glib::Error>) + 'static>(location: &str, priority: glib::Priority, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        assert_initialized_main_thread!();
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn create_from_location_async_trampoline<P: FnOnce(Result<Tree, glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) { unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::osinfo_tree_create_from_location_finish(res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }}
        let callback = create_from_location_async_trampoline::<P>;
        unsafe {
            ffi::osinfo_tree_create_from_location_async(location.to_glib_none().0, priority.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    pub fn create_from_location_future(location: &str, priority: glib::Priority) -> Pin<Box_<dyn std::future::Future<Output = Result<Tree, glib::Error>> + 'static>> {

        skip_assert_initialized!();
        let location = String::from(location);
        Box_::pin(gio::GioFuture::new(&(), move |_obj, cancellable, send| {
            Self::create_from_location_async(
                &location,
                priority,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Creates a new [`Tree`][crate::Tree] for installation tree represented by `treeinfo`.
    /// ## `treeinfo`
    /// a string representing the .treeinfo content
    /// ## `location`
    /// the location of the original `treeinfo`
    ///
    /// # Returns
    ///
    /// a new [`Tree`][crate::Tree], or NULL on error
    #[cfg(feature = "v1_7")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_7")))]
    #[doc(alias = "osinfo_tree_create_from_treeinfo")]
    pub fn create_from_treeinfo(treeinfo: &str, location: &str) -> Result<Tree, glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::osinfo_tree_create_from_treeinfo(treeinfo.to_glib_none().0, location.to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }
}

impl Default for Tree {
                     fn default() -> Self {
                         glib::object::Object::new::<Self>()
                     }
                 }

// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`Tree`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct TreeBuilder {
            builder: glib::object::ObjectBuilder<'static, Tree>,
        }

        impl TreeBuilder {
        fn new() -> Self {
            Self { builder: glib::object::Object::builder() }
        }

                            /// The target hardware architecture of this tree.
                            pub fn architecture(self, architecture: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("architecture", architecture.into()), }
                        }

                            /// The path to the boot ISO in the install tree
                            pub fn boot_iso_path(self, boot_iso_path: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("boot-iso-path", boot_iso_path.into()), }
                        }

                            /// Whether the tree has treeinfo or not
                            pub fn has_treeinfo(self, has_treeinfo: bool) -> Self {
                            Self { builder: self.builder.property("has-treeinfo", has_treeinfo), }
                        }

                            /// The path to the initrd image in the install tree.
                            pub fn initrd_path(self, initrd_path: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("initrd-path", initrd_path.into()), }
                        }

                            /// The path to the kernel image in the install tree.
                            pub fn kernel_path(self, kernel_path: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("kernel-path", kernel_path.into()), }
                        }

                            /// Os information for the current tree. For tree stored in an
                            /// [`Db`][crate::Db], it will be filled when the database is loaded, otherwise
                            /// the property will be filled after a successful call to
                            /// [`DbExt::identify_tree()`][crate::prelude::DbExt::identify_tree()].
                            pub fn os(self, os: &impl IsA<Os>) -> Self {
                            Self { builder: self.builder.property("os", os.clone().upcast()), }
                        }

                            /// The treeinfo arch
                            pub fn treeinfo_arch(self, treeinfo_arch: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("treeinfo-arch", treeinfo_arch.into()), }
                        }

                            /// The treeinfo family
                            pub fn treeinfo_family(self, treeinfo_family: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("treeinfo-family", treeinfo_family.into()), }
                        }

                            /// The treeinfo variant
                            pub fn treeinfo_variant(self, treeinfo_variant: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("treeinfo-variant", treeinfo_variant.into()), }
                        }

                            /// The treeinfo version
                            pub fn treeinfo_version(self, treeinfo_version: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("treeinfo-version", treeinfo_version.into()), }
                        }

                            /// The URL to this tree.
                            pub fn url(self, url: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("url", url.into()), }
                        }

                            /// The unique identifier for the entity The format of identifiers
                            /// is undefined, but the recommended practice is to use a URI.
                            /// This parameter must be set at time of construction as no
                            /// default value is provided.
                            pub fn id(self, id: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("id", id.into()), }
                        }

    // rustdoc-stripper-ignore-next
    /// Build the [`Tree`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> Tree {
assert_initialized_main_thread!();
    self.builder.build() }
}

/// Trait containing all [`struct@Tree`] methods.
///
/// # Implementors
///
/// [`Tree`][struct@crate::Tree]
pub trait TreeExt: IsA<Tree> + 'static {
    /// Retrieves the target hardware architecture of the OS `self` provides.
    ///
    /// # Returns
    ///
    /// the hardware architecture, or NULL
    #[doc(alias = "osinfo_tree_get_architecture")]
    #[doc(alias = "get_architecture")]
    fn architecture(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_tree_get_architecture(self.as_ref().to_glib_none().0))
        }
    }

    /// Retrieves the path to the boot_iso image in the install tree.
    ///
    /// # Returns
    ///
    /// the path to boot_iso image, or NULL
    #[doc(alias = "osinfo_tree_get_boot_iso_path")]
    #[doc(alias = "get_boot_iso_path")]
    #[doc(alias = "boot-iso-path")]
    fn boot_iso_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_tree_get_boot_iso_path(self.as_ref().to_glib_none().0))
        }
    }

    /// Retrieves the path to the initrd image in the install tree.
    ///
    /// Note: This only applies to installer trees of 'linux' OS family.
    ///
    /// # Returns
    ///
    /// the path to initrd image, or NULL
    #[doc(alias = "osinfo_tree_get_initrd_path")]
    #[doc(alias = "get_initrd_path")]
    #[doc(alias = "initrd-path")]
    fn initrd_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_tree_get_initrd_path(self.as_ref().to_glib_none().0))
        }
    }

    /// Retrieves the path to the kernel image in the install tree.
    ///
    /// Note: This only applies to installer trees of 'linux' OS family.
    ///
    /// # Returns
    ///
    /// the path to kernel image, or NULL
    #[doc(alias = "osinfo_tree_get_kernel_path")]
    #[doc(alias = "get_kernel_path")]
    #[doc(alias = "kernel-path")]
    fn kernel_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_tree_get_kernel_path(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the operating system, or NULL
    #[cfg(feature = "v1_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_5")))]
    #[doc(alias = "osinfo_tree_get_os")]
    #[doc(alias = "get_os")]
    fn os(&self) -> Option<Os> {
        unsafe {
            from_glib_full(ffi::osinfo_tree_get_os(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the variants of the associated operating system.
    ///
    /// # Returns
    ///
    /// the operating system variant, or NULL
    #[cfg(feature = "v1_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_5")))]
    #[doc(alias = "osinfo_tree_get_os_variants")]
    #[doc(alias = "get_os_variants")]
    fn os_variants(&self) -> Option<OsVariantList> {
        unsafe {
            from_glib_full(ffi::osinfo_tree_get_os_variants(self.as_ref().to_glib_none().0))
        }
    }

    /// If `self` has treeinfo, this function retrieves the expected architecture.
    ///
    /// Note: In practice, this will usually not be the exact copy of the
    /// architecture but rather a regular expression that matches it.
    ///
    /// # Returns
    ///
    /// the treeinfo architecture, or NULL
    #[doc(alias = "osinfo_tree_get_treeinfo_arch")]
    #[doc(alias = "get_treeinfo_arch")]
    #[doc(alias = "treeinfo-arch")]
    fn treeinfo_arch(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_tree_get_treeinfo_arch(self.as_ref().to_glib_none().0))
        }
    }

    /// If `self` has treeinfo, this function retrieves the expected family.
    ///
    /// Note: In practice, this will usually not be the exact copy of the family
    /// but rather a regular expression that matches it.
    ///
    /// # Returns
    ///
    /// the treeinfo family, or NULL
    #[doc(alias = "osinfo_tree_get_treeinfo_family")]
    #[doc(alias = "get_treeinfo_family")]
    #[doc(alias = "treeinfo-family")]
    fn treeinfo_family(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_tree_get_treeinfo_family(self.as_ref().to_glib_none().0))
        }
    }

    /// If `self` has treeinfo, this function retrieves the expected variant.
    ///
    /// Note: In practice, this will usually not be the exact copy of the variant
    /// but rather a regular expression that matches it.
    ///
    /// # Returns
    ///
    /// the treeinfo variant, or NULL
    #[doc(alias = "osinfo_tree_get_treeinfo_variant")]
    #[doc(alias = "get_treeinfo_variant")]
    #[doc(alias = "treeinfo-variant")]
    fn treeinfo_variant(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_tree_get_treeinfo_variant(self.as_ref().to_glib_none().0))
        }
    }

    /// If `self` has treeinfo, this function retrieves the expected version.
    ///
    /// Note: In practice, this will usually not be the exact copy of version but
    /// rather a regular expression that matches it.
    ///
    /// # Returns
    ///
    /// the treeinfo version, or NULL
    #[doc(alias = "osinfo_tree_get_treeinfo_version")]
    #[doc(alias = "get_treeinfo_version")]
    #[doc(alias = "treeinfo-version")]
    fn treeinfo_version(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_tree_get_treeinfo_version(self.as_ref().to_glib_none().0))
        }
    }

    /// The URL to the `self`
    ///
    /// # Returns
    ///
    /// the URL, or NULL
    #[doc(alias = "osinfo_tree_get_url")]
    #[doc(alias = "get_url")]
    fn url(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_tree_get_url(self.as_ref().to_glib_none().0))
        }
    }

    /// Return whether a tree has treeinfo or not.
    ///
    /// # Returns
    ///
    /// TRUE if the tree has treeinfo. FALSE otherwise.
    #[cfg(feature = "v1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_3")))]
    #[doc(alias = "osinfo_tree_has_treeinfo")]
    fn has_treeinfo(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_tree_has_treeinfo(self.as_ref().to_glib_none().0))
        }
    }

    /// Determines whether the metadata for the unidentified `self` is a match
    /// for the `reference` tree.
    ///
    /// The metadata in the unidentified `self` must be literal strings,
    /// while the metadata in the `reference` tree must be regular expressions.
    /// ## `reference`
    /// a reference [`Tree`][crate::Tree] instance
    ///
    /// # Returns
    ///
    /// [`true`] if `self` is a match for `reference`. [`false`] otherwise
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    #[doc(alias = "osinfo_tree_matches")]
    fn matches(&self, reference: &impl IsA<Tree>) -> bool {
        unsafe {
            from_glib(ffi::osinfo_tree_matches(self.as_ref().to_glib_none().0, reference.as_ref().to_glib_none().0))
        }
    }

    /// Sets the [`Os`][crate::Os] associated to the [`Tree`][crate::Tree] instance.
    /// ## `os`
    /// an [`Os`][crate::Os] instance
    #[cfg(feature = "v1_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_5")))]
    #[doc(alias = "osinfo_tree_set_os")]
    #[doc(alias = "os")]
    fn set_os(&self, os: &impl IsA<Os>) {
        unsafe {
            ffi::osinfo_tree_set_os(self.as_ref().to_glib_none().0, os.as_ref().to_glib_none().0);
        }
    }

    /// The target hardware architecture of this tree.
    fn set_architecture(&self, architecture: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"architecture", architecture)
    }

    /// The path to the boot ISO in the install tree
    #[doc(alias = "boot-iso-path")]
    fn set_boot_iso_path(&self, boot_iso_path: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"boot-iso-path", boot_iso_path)
    }

    /// Whether the tree has treeinfo or not
    #[doc(alias = "has-treeinfo")]
    fn get_property_has_treeinfo(&self) -> bool {
        ObjectExt::property(self.as_ref(), "has-treeinfo")
    }

    /// Whether the tree has treeinfo or not
    #[doc(alias = "has-treeinfo")]
    fn set_has_treeinfo(&self, has_treeinfo: bool) {
        ObjectExt::set_property(self.as_ref(),"has-treeinfo", has_treeinfo)
    }

    /// The path to the initrd image in the install tree.
    #[doc(alias = "initrd-path")]
    fn set_initrd_path(&self, initrd_path: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"initrd-path", initrd_path)
    }

    /// The path to the kernel image in the install tree.
    #[doc(alias = "kernel-path")]
    fn set_kernel_path(&self, kernel_path: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"kernel-path", kernel_path)
    }

    #[cfg(not(feature = "v1_5"))]
    #[cfg_attr(docsrs, doc(cfg(not(feature = "v1_5"))))]
    fn os(&self) -> Option<Os> {
        ObjectExt::property(self.as_ref(), "os")
    }

    #[cfg(not(feature = "v1_5"))]
    #[cfg_attr(docsrs, doc(cfg(not(feature = "v1_5"))))]
    fn set_os<P: IsA<Os>>(&self, os: Option<&P>) {
        ObjectExt::set_property(self.as_ref(),"os", os)
    }

    /// The treeinfo arch
    #[doc(alias = "treeinfo-arch")]
    fn set_treeinfo_arch(&self, treeinfo_arch: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"treeinfo-arch", treeinfo_arch)
    }

    /// The treeinfo family
    #[doc(alias = "treeinfo-family")]
    fn set_treeinfo_family(&self, treeinfo_family: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"treeinfo-family", treeinfo_family)
    }

    /// The treeinfo variant
    #[doc(alias = "treeinfo-variant")]
    fn set_treeinfo_variant(&self, treeinfo_variant: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"treeinfo-variant", treeinfo_variant)
    }

    /// The treeinfo version
    #[doc(alias = "treeinfo-version")]
    fn set_treeinfo_version(&self, treeinfo_version: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"treeinfo-version", treeinfo_version)
    }

    /// The URL to this tree.
    fn set_url(&self, url: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"url", url)
    }

    #[doc(alias = "architecture")]
    fn connect_architecture_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_architecture_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::architecture".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_architecture_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "boot-iso-path")]
    fn connect_boot_iso_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_boot_iso_path_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::boot-iso-path".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_boot_iso_path_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "has-treeinfo")]
    fn connect_has_treeinfo_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_has_treeinfo_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::has-treeinfo".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_has_treeinfo_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "initrd-path")]
    fn connect_initrd_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_initrd_path_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::initrd-path".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_initrd_path_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "kernel-path")]
    fn connect_kernel_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_kernel_path_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::kernel-path".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_kernel_path_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "os")]
    fn connect_os_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_os_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::os".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_os_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "treeinfo-arch")]
    fn connect_treeinfo_arch_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_treeinfo_arch_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::treeinfo-arch".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_treeinfo_arch_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "treeinfo-family")]
    fn connect_treeinfo_family_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_treeinfo_family_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::treeinfo-family".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_treeinfo_family_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "treeinfo-variant")]
    fn connect_treeinfo_variant_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_treeinfo_variant_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::treeinfo-variant".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_treeinfo_variant_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "treeinfo-version")]
    fn connect_treeinfo_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_treeinfo_version_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::treeinfo-version".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_treeinfo_version_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "url")]
    fn connect_url_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_url_trampoline<P: IsA<Tree>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoTree, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Tree::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::url".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_url_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Tree>> TreeExt for O {}
