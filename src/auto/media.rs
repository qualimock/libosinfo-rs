// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../girs
// DO NOT EDIT

use crate::{ffi,Entity,Os,OsVariantList};
#[cfg(feature = "v1_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
use crate::{InstallScript,InstallScriptList};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_,pin::Pin};

glib::wrapper! {
    ///
    ///
    /// ## Properties
    ///
    ///
    /// #### `application-id`
    ///  Expected application ID (regular expression) for ISO9660 image/device.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `architecture`
    ///  The target hardware architecture of this media.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `eject-after-install`
    ///  Whether the media should be ejected after the installation process.
    ///
    /// Some distros need their media to not be ejected after the final reboot
    /// during its installation process as some packages are installed after the
    /// reboot (which may cause the media to be ejected, depending on the
    /// application).
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `initrd-path`
    ///  The path to the initrd image in the install tree.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `installer`
    ///  Whether media provides an installer for an OS.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `installer-reboots`
    ///  If media is an installer, this property indicates the number of reboots
    /// the installer takes before installation is complete.
    ///
    /// This property is not applicable to media that has no installer. You can
    /// use `osinfo_media_get_installer`(or OsinfoMedia::installer) to check
    /// that.
    ///
    /// Warning: Some media allow you to install from live sessions, in which
    /// case number of reboots *alone* is not a reliable method for tracking
    /// installation.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `installer-script`
    ///  Whether the media supports installation via an install-script.
    ///
    /// Some distros provide a few different medias and not all the medias support
    /// installation via an install script.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `kernel-path`
    ///  The path to the kernel image in the install tree.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `languages`
    ///  If media is an installer, this property indicates the languages that
    /// can be used during automatic installations.
    ///
    /// On media that are not installers, this property will indicate the
    /// languages that the user interface can be displayed in.
    /// Use `osinfo_media_get_installer`(or OsinfoMedia::installer) to know
    /// if the media is an installer or not.
    ///
    /// Readable
    ///
    ///
    /// #### `live`
    ///  Whether media can boot directly an OS without any installations.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `os`
    ///  Os information for the current media. For media stored in an
    /// [`Db`][crate::Db], it will be filled when the database is loaded, otherwise
    /// the property will be filled after a successful call to
    /// [`DbExt::identify_media()`][crate::prelude::DbExt::identify_media()].
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `publisher-id`
    ///  Expected publisher ID (regular expression) for ISO9660 image/device.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `system-id`
    ///  Expected system ID (regular expression) for ISO9660 image/device.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `url`
    ///  The URL to this media.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `volume-id`
    ///  Expected volume ID (regular expression) for ISO9660 image/device.
    ///
    /// Readable | Writeable
    ///
    ///
    /// #### `volume-size`
    ///  Expected volume size, in bytes for ISO9660 image/device.
    ///
    /// Readable | Writeable
    /// <details><summary><h4>Entity</h4></summary>
    ///
    ///
    /// #### `id`
    ///  The unique identifier for the entity The format of identifiers
    /// is undefined, but the recommended practice is to use a URI.
    /// This parameter must be set at time of construction as no
    /// default value is provided.
    ///
    /// Readable | Writeable | Construct
    /// </details>
    ///
    /// # Implements
    ///
    /// [`MediaExt`][trait@crate::prelude::MediaExt], [`EntityExt`][trait@crate::prelude::EntityExt]
    #[doc(alias = "OsinfoMedia")]
    pub struct Media(Object<ffi::OsinfoMedia, ffi::OsinfoMediaClass>) @extends Entity;

    match fn {
        type_ => || ffi::osinfo_media_get_type(),
    }
}

impl Media {
        pub const NONE: Option<&'static Media> = None;
    

    #[doc(alias = "osinfo_media_new")]
    pub fn new(id: &str, architecture: &str) -> Media {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::osinfo_media_new(id.to_glib_none().0, architecture.to_glib_none().0))
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`Media`] objects.
            ///
            /// This method returns an instance of [`MediaBuilder`](crate::builders::MediaBuilder) which can be used to create [`Media`] objects.
            pub fn builder() -> MediaBuilder {
                MediaBuilder::new()
            }
        

    /// Creates a new [`Media`][crate::Media] for installation media at `location`. The `location`
    /// could be a http:// or a https:// URI or a local path.
    ///
    /// NOTE: Currently this only works for ISO images/devices.
    /// ## `location`
    /// the location of an installation media
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    ///
    /// # Returns
    ///
    /// a new [`Media`][crate::Media] , or NULL on error
    #[doc(alias = "osinfo_media_create_from_location")]
    pub fn create_from_location(location: &str, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<Media, glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::osinfo_media_create_from_location(location.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    /// Asynchronous variant of `osinfo_media_create_from_location`.
    /// ## `location`
    /// the location of an installation media
    /// ## `priority`
    /// the I/O priority of the request
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    /// ## `callback`
    /// Function to call when result of this call is ready
    #[doc(alias = "osinfo_media_create_from_location_async")]
    pub fn create_from_location_async<P: FnOnce(Result<Media, glib::Error>) + 'static>(location: &str, priority: glib::Priority, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        assert_initialized_main_thread!();
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn create_from_location_async_trampoline<P: FnOnce(Result<Media, glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) { unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::osinfo_media_create_from_location_finish(res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }}
        let callback = create_from_location_async_trampoline::<P>;
        unsafe {
            ffi::osinfo_media_create_from_location_async(location.to_glib_none().0, priority.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    pub fn create_from_location_future(location: &str, priority: glib::Priority) -> Pin<Box_<dyn std::future::Future<Output = Result<Media, glib::Error>> + 'static>> {

        skip_assert_initialized!();
        let location = String::from(location);
        Box_::pin(gio::GioFuture::new(&(), move |_obj, cancellable, send| {
            Self::create_from_location_async(
                &location,
                priority,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Creates a new [`Media`][crate::Media] for installation media at `location`. The `location`
    /// could be a http:// or a https:// URI or a local path.
    ///
    /// NOTE: Currently this only works for ISO images/devices.
    /// ## `location`
    /// the location of an installation media
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    /// ## `flags`
    /// An `OsinfoMediaDetectFlag`, or 0.
    ///
    /// # Returns
    ///
    /// a new [`Media`][crate::Media] , or NULL on error
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "osinfo_media_create_from_location_with_flags")]
    pub fn create_from_location_with_flags(location: &str, cancellable: Option<&impl IsA<gio::Cancellable>>, flags: u32) -> Result<Media, glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::osinfo_media_create_from_location_with_flags(location.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, flags, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    /// Asynchronous variant of `osinfo_media_create_from_location_with_flags`.
    /// ## `location`
    /// the location of an installation media
    /// ## `priority`
    /// the I/O priority of the request
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable], or [`None`]
    /// ## `callback`
    /// Function to call when result of this call is ready
    /// ## `flags`
    /// An `OsinfoMediaDetectFlag`, or 0.
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "osinfo_media_create_from_location_with_flags_async")]
    pub fn create_from_location_with_flags_async<P: FnOnce(Result<Media, glib::Error>) + 'static>(location: &str, priority: glib::Priority, cancellable: Option<&impl IsA<gio::Cancellable>>, flags: u32, callback: P) {
        assert_initialized_main_thread!();
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn create_from_location_with_flags_async_trampoline<P: FnOnce(Result<Media, glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) { unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::osinfo_media_create_from_location_with_flags_finish(res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }}
        let callback = create_from_location_with_flags_async_trampoline::<P>;
        unsafe {
            ffi::osinfo_media_create_from_location_with_flags_async(location.to_glib_none().0, priority.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), flags, Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    pub fn create_from_location_with_flags_future(location: &str, priority: glib::Priority, flags: u32) -> Pin<Box_<dyn std::future::Future<Output = Result<Media, glib::Error>> + 'static>> {

        skip_assert_initialized!();
        let location = String::from(location);
        Box_::pin(gio::GioFuture::new(&(), move |_obj, cancellable, send| {
            Self::create_from_location_with_flags_async(
                &location,
                priority,
                Some(cancellable),
                flags,
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }
}

impl Default for Media {
                     fn default() -> Self {
                         glib::object::Object::new::<Self>()
                     }
                 }

// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`Media`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct MediaBuilder {
            builder: glib::object::ObjectBuilder<'static, Media>,
        }

        impl MediaBuilder {
        fn new() -> Self {
            Self { builder: glib::object::Object::builder() }
        }

                            /// Expected application ID (regular expression) for ISO9660 image/device.
                            pub fn application_id(self, application_id: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("application-id", application_id.into()), }
                        }

                            /// The target hardware architecture of this media.
                            pub fn architecture(self, architecture: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("architecture", architecture.into()), }
                        }

                            /// Whether the media should be ejected after the installation process.
                            ///
                            /// Some distros need their media to not be ejected after the final reboot
                            /// during its installation process as some packages are installed after the
                            /// reboot (which may cause the media to be ejected, depending on the
                            /// application).
                            pub fn eject_after_install(self, eject_after_install: bool) -> Self {
                            Self { builder: self.builder.property("eject-after-install", eject_after_install), }
                        }

                            /// The path to the initrd image in the install tree.
                            pub fn initrd_path(self, initrd_path: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("initrd-path", initrd_path.into()), }
                        }

                            /// Whether media provides an installer for an OS.
                            pub fn installer(self, installer: bool) -> Self {
                            Self { builder: self.builder.property("installer", installer), }
                        }

                            /// If media is an installer, this property indicates the number of reboots
                            /// the installer takes before installation is complete.
                            ///
                            /// This property is not applicable to media that has no installer. You can
                            /// use `osinfo_media_get_installer`(or OsinfoMedia::installer) to check
                            /// that.
                            ///
                            /// Warning: Some media allow you to install from live sessions, in which
                            /// case number of reboots *alone* is not a reliable method for tracking
                            /// installation.
                            pub fn installer_reboots(self, installer_reboots: i32) -> Self {
                            Self { builder: self.builder.property("installer-reboots", installer_reboots), }
                        }

                            /// Whether the media supports installation via an install-script.
                            ///
                            /// Some distros provide a few different medias and not all the medias support
                            /// installation via an install script.
                            pub fn installer_script(self, installer_script: bool) -> Self {
                            Self { builder: self.builder.property("installer-script", installer_script), }
                        }

                            /// The path to the kernel image in the install tree.
                            pub fn kernel_path(self, kernel_path: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("kernel-path", kernel_path.into()), }
                        }

                            /// Whether media can boot directly an OS without any installations.
                            pub fn live(self, live: bool) -> Self {
                            Self { builder: self.builder.property("live", live), }
                        }

                            /// Os information for the current media. For media stored in an
                            /// [`Db`][crate::Db], it will be filled when the database is loaded, otherwise
                            /// the property will be filled after a successful call to
                            /// [`DbExt::identify_media()`][crate::prelude::DbExt::identify_media()].
                            pub fn os(self, os: &impl IsA<Os>) -> Self {
                            Self { builder: self.builder.property("os", os.clone().upcast()), }
                        }

                            /// Expected publisher ID (regular expression) for ISO9660 image/device.
                            pub fn publisher_id(self, publisher_id: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("publisher-id", publisher_id.into()), }
                        }

                            /// Expected system ID (regular expression) for ISO9660 image/device.
                            pub fn system_id(self, system_id: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("system-id", system_id.into()), }
                        }

                            /// The URL to this media.
                            pub fn url(self, url: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("url", url.into()), }
                        }

                            /// Expected volume ID (regular expression) for ISO9660 image/device.
                            pub fn volume_id(self, volume_id: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("volume-id", volume_id.into()), }
                        }

                            /// Expected volume size, in bytes for ISO9660 image/device.
                            pub fn volume_size(self, volume_size: i64) -> Self {
                            Self { builder: self.builder.property("volume-size", volume_size), }
                        }

                            /// The unique identifier for the entity The format of identifiers
                            /// is undefined, but the recommended practice is to use a URI.
                            /// This parameter must be set at time of construction as no
                            /// default value is provided.
                            pub fn id(self, id: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("id", id.into()), }
                        }

    // rustdoc-stripper-ignore-next
    /// Build the [`Media`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> Media {
assert_initialized_main_thread!();
    self.builder.build() }
}

/// Trait containing all [`struct@Media`] methods.
///
/// # Implementors
///
/// [`Media`][struct@crate::Media]
pub trait MediaExt: IsA<Media> + 'static {
    /// Adds an `script` to the specified `self`
    /// ## `script`
    /// an [`InstallScript`][crate::InstallScript] instance
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    #[doc(alias = "osinfo_media_add_install_script")]
    fn add_install_script(&self, script: &impl IsA<InstallScript>) {
        unsafe {
            ffi::osinfo_media_add_install_script(self.as_ref().to_glib_none().0, script.as_ref().to_glib_none().0);
        }
    }

    /// If `self` is an ISO9660 image/device, this function retrieves the expected
    /// application ID.
    ///
    /// Note: In practice, this will usually not be the exact copy of the application
    /// ID string on the ISO image/device but rather a regular expression that
    /// matches it.
    ///
    /// # Returns
    ///
    /// the application id, or NULL
    #[doc(alias = "osinfo_media_get_application_id")]
    #[doc(alias = "get_application_id")]
    #[doc(alias = "application-id")]
    fn application_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_media_get_application_id(self.as_ref().to_glib_none().0))
        }
    }

    /// Retrieves the target hardware architecture of the OS `self` provides.
    ///
    /// # Returns
    ///
    /// the hardware architecture, or NULL
    #[doc(alias = "osinfo_media_get_architecture")]
    #[doc(alias = "get_architecture")]
    fn architecture(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_media_get_architecture(self.as_ref().to_glib_none().0))
        }
    }

    /// Whether `self` should ejected after the installation procces.
    ///
    /// # Returns
    ///
    /// [`true`] if media should be ejected, [`false`] otherwise
    #[doc(alias = "osinfo_media_get_eject_after_install")]
    #[doc(alias = "get_eject_after_install")]
    #[doc(alias = "eject-after-install")]
    fn is_eject_after_install(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_media_get_eject_after_install(self.as_ref().to_glib_none().0))
        }
    }

    /// Retrieves the path to the initrd image in the install tree.
    ///
    /// Note: This only applies to installer medias of 'linux' OS family.
    ///
    /// # Returns
    ///
    /// the path to initrd image, or NULL
    #[doc(alias = "osinfo_media_get_initrd_path")]
    #[doc(alias = "get_initrd_path")]
    #[doc(alias = "initrd-path")]
    fn initrd_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_media_get_initrd_path(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// a list of the install scripts for the specified media
    #[cfg(feature = "v1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_4")))]
    #[doc(alias = "osinfo_media_get_install_script_list")]
    #[doc(alias = "get_install_script_list")]
    fn install_script_list(&self) -> Option<InstallScriptList> {
        unsafe {
            from_glib_full(ffi::osinfo_media_get_install_script_list(self.as_ref().to_glib_none().0))
        }
    }

    /// Whether `self` provides an installer for an OS.
    ///
    /// # Returns
    ///
    /// [`true`] if media is installer, [`false`] otherwise
    #[doc(alias = "osinfo_media_get_installer")]
    #[doc(alias = "get_installer")]
    #[doc(alias = "installer")]
    fn is_installer(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_media_get_installer(self.as_ref().to_glib_none().0))
        }
    }

    /// If media is an installer, this method retrieves the number of reboots the
    /// installer takes before installation is complete.
    ///
    /// This function is not supposed to be called on media that has no installer.
    /// You can use `osinfo_media_get_installer`(or OsinfoMedia::installer) to check
    /// that.
    ///
    /// Warning: Some media allow you to install from live sessions, in which case
    /// number of reboots *alone* is not a reliable method for tracking installation.
    ///
    /// # Returns
    ///
    /// the number of installer reboots or -1 if media is not an installer
    #[doc(alias = "osinfo_media_get_installer_reboots")]
    #[doc(alias = "get_installer_reboots")]
    #[doc(alias = "installer-reboots")]
    fn installer_reboots(&self) -> i32 {
        unsafe {
            ffi::osinfo_media_get_installer_reboots(self.as_ref().to_glib_none().0)
        }
    }

    /// Retrieves the path to the kernel image in the install tree.
    ///
    /// Note: This only applies to installer medias of 'linux' OS family.
    ///
    /// # Returns
    ///
    /// the path to kernel image, or NULL
    #[doc(alias = "osinfo_media_get_kernel_path")]
    #[doc(alias = "get_kernel_path")]
    #[doc(alias = "kernel-path")]
    fn kernel_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_media_get_kernel_path(self.as_ref().to_glib_none().0))
        }
    }

    /// If media is an installer, this property indicates the languages that
    /// can be used during automatic installations.
    ///
    /// On media that are not installers, this property will indicate the
    /// languages that the user interface can be displayed in.
    /// Use `osinfo_media_get_installer`(or OsinfoMedia::installer) to know
    /// if the media is an installer or not.
    ///
    /// # Returns
    ///
    /// a `GList`
    /// containing the list of the UI languages this media supports. The list
    /// must be freed with `g_list_free()` when no longer needed. If the
    /// supported languages are unknown, NULL will be returned.
    #[doc(alias = "osinfo_media_get_languages")]
    #[doc(alias = "get_languages")]
    fn languages(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::osinfo_media_get_languages(self.as_ref().to_glib_none().0))
        }
    }

    /// Whether `self` can boot directly an OS without any installations.
    ///
    /// # Returns
    ///
    /// [`true`] if media is live, [`false`] otherwise
    #[doc(alias = "osinfo_media_get_live")]
    #[doc(alias = "get_live")]
    #[doc(alias = "live")]
    fn is_live(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_media_get_live(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the operating system, or NULL
    #[doc(alias = "osinfo_media_get_os")]
    #[doc(alias = "get_os")]
    fn os(&self) -> Option<Os> {
        unsafe {
            from_glib_full(ffi::osinfo_media_get_os(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the variants of the associated operating system.
    ///
    /// # Returns
    ///
    /// the operating system variant, or NULL
    #[doc(alias = "osinfo_media_get_os_variants")]
    #[doc(alias = "get_os_variants")]
    fn os_variants(&self) -> Option<OsVariantList> {
        unsafe {
            from_glib_full(ffi::osinfo_media_get_os_variants(self.as_ref().to_glib_none().0))
        }
    }

    /// If `self` is an ISO9660 image/device, this function retrieves the expected
    /// publisher ID.
    ///
    /// Note: In practice, this will usually not be the exact copy of the publisher
    /// ID string on the ISO image/device but rather a regular expression that
    /// matches it.
    ///
    /// # Returns
    ///
    /// the publisher id, or NULL
    #[doc(alias = "osinfo_media_get_publisher_id")]
    #[doc(alias = "get_publisher_id")]
    #[doc(alias = "publisher-id")]
    fn publisher_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_media_get_publisher_id(self.as_ref().to_glib_none().0))
        }
    }

    /// If `self` is an ISO9660 image/device, this function retrieves the expected
    /// system ID.
    ///
    /// Note: In practice, this will usually not be the exact copy of the system ID
    /// string on the ISO image/device but rather a regular expression that matches
    /// it.
    ///
    /// # Returns
    ///
    /// the system id, or NULL
    #[doc(alias = "osinfo_media_get_system_id")]
    #[doc(alias = "get_system_id")]
    #[doc(alias = "system-id")]
    fn system_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_media_get_system_id(self.as_ref().to_glib_none().0))
        }
    }

    /// The URL to the `self`
    ///
    /// # Returns
    ///
    /// the URL, or NULL
    #[doc(alias = "osinfo_media_get_url")]
    #[doc(alias = "get_url")]
    fn url(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_media_get_url(self.as_ref().to_glib_none().0))
        }
    }

    /// If `self` is an ISO9660 image/device, this function retrieves the expected
    /// volume ID.
    ///
    /// Note: In practice, this will usually not be the exact copy of the volume ID
    /// string on the ISO image/device but rather a regular expression that matches
    /// it.
    ///
    /// # Returns
    ///
    /// the volume id, or NULL
    #[doc(alias = "osinfo_media_get_volume_id")]
    #[doc(alias = "get_volume_id")]
    #[doc(alias = "volume-id")]
    fn volume_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_media_get_volume_id(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the ISO9660 volume size, in bytes or -1 if size is
    /// unknown or media is not an ISO9660 device/image.
    #[doc(alias = "osinfo_media_get_volume_size")]
    #[doc(alias = "get_volume_size")]
    #[doc(alias = "volume-size")]
    fn volume_size(&self) -> i64 {
        unsafe {
            ffi::osinfo_media_get_volume_size(self.as_ref().to_glib_none().0)
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if the `self` is bootable. [`false`] otherwise.
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "osinfo_media_is_bootable")]
    fn is_bootable(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_media_is_bootable(self.as_ref().to_glib_none().0))
        }
    }

    /// Determines whether the metadata for the unidentified `self` is a match
    /// for the `reference` media.
    ///
    /// The metadata in the unidentified `self` must be literal strings,
    /// while the metadata in the `reference` media must be regular expressions.
    /// ## `reference`
    /// a reference [`Media`][crate::Media] instance
    ///
    /// # Returns
    ///
    /// [`true`] if `self` is a match for `reference`. [`false`] otherwise
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    #[doc(alias = "osinfo_media_matches")]
    fn matches(&self, reference: &impl IsA<Media>) -> bool {
        unsafe {
            from_glib(ffi::osinfo_media_matches(self.as_ref().to_glib_none().0, reference.as_ref().to_glib_none().0))
        }
    }

    /// Whether `self` supports installation using install scripts.
    ///
    /// # Returns
    ///
    /// [`true`] if install-scripts are supported by the media,
    /// [`false`] otherwise
    #[cfg(feature = "v1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_3")))]
    #[doc(alias = "osinfo_media_supports_installer_script")]
    fn supports_installer_script(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_media_supports_installer_script(self.as_ref().to_glib_none().0))
        }
    }

    /// Expected application ID (regular expression) for ISO9660 image/device.
    #[doc(alias = "application-id")]
    fn set_application_id(&self, application_id: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"application-id", application_id)
    }

    /// The target hardware architecture of this media.
    fn set_architecture(&self, architecture: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"architecture", architecture)
    }

    /// Whether the media should be ejected after the installation process.
    ///
    /// Some distros need their media to not be ejected after the final reboot
    /// during its installation process as some packages are installed after the
    /// reboot (which may cause the media to be ejected, depending on the
    /// application).
    #[doc(alias = "eject-after-install")]
    fn set_eject_after_install(&self, eject_after_install: bool) {
        ObjectExt::set_property(self.as_ref(),"eject-after-install", eject_after_install)
    }

    /// The path to the initrd image in the install tree.
    #[doc(alias = "initrd-path")]
    fn set_initrd_path(&self, initrd_path: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"initrd-path", initrd_path)
    }

    /// Whether media provides an installer for an OS.
    fn set_installer(&self, installer: bool) {
        ObjectExt::set_property(self.as_ref(),"installer", installer)
    }

    /// If media is an installer, this property indicates the number of reboots
    /// the installer takes before installation is complete.
    ///
    /// This property is not applicable to media that has no installer. You can
    /// use `osinfo_media_get_installer`(or OsinfoMedia::installer) to check
    /// that.
    ///
    /// Warning: Some media allow you to install from live sessions, in which
    /// case number of reboots *alone* is not a reliable method for tracking
    /// installation.
    #[doc(alias = "installer-reboots")]
    fn set_installer_reboots(&self, installer_reboots: i32) {
        ObjectExt::set_property(self.as_ref(),"installer-reboots", installer_reboots)
    }

    /// Whether the media supports installation via an install-script.
    ///
    /// Some distros provide a few different medias and not all the medias support
    /// installation via an install script.
    #[doc(alias = "installer-script")]
    fn is_installer_script(&self) -> bool {
        ObjectExt::property(self.as_ref(), "installer-script")
    }

    /// Whether the media supports installation via an install-script.
    ///
    /// Some distros provide a few different medias and not all the medias support
    /// installation via an install script.
    #[doc(alias = "installer-script")]
    fn set_installer_script(&self, installer_script: bool) {
        ObjectExt::set_property(self.as_ref(),"installer-script", installer_script)
    }

    /// The path to the kernel image in the install tree.
    #[doc(alias = "kernel-path")]
    fn set_kernel_path(&self, kernel_path: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"kernel-path", kernel_path)
    }

    /// Whether media can boot directly an OS without any installations.
    fn set_live(&self, live: bool) {
        ObjectExt::set_property(self.as_ref(),"live", live)
    }

    /// Os information for the current media. For media stored in an
    /// [`Db`][crate::Db], it will be filled when the database is loaded, otherwise
    /// the property will be filled after a successful call to
    /// [`DbExt::identify_media()`][crate::prelude::DbExt::identify_media()].
    fn set_os<P: IsA<Os>>(&self, os: Option<&P>) {
        ObjectExt::set_property(self.as_ref(),"os", os)
    }

    /// Expected publisher ID (regular expression) for ISO9660 image/device.
    #[doc(alias = "publisher-id")]
    fn set_publisher_id(&self, publisher_id: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"publisher-id", publisher_id)
    }

    /// Expected system ID (regular expression) for ISO9660 image/device.
    #[doc(alias = "system-id")]
    fn set_system_id(&self, system_id: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"system-id", system_id)
    }

    /// The URL to this media.
    fn set_url(&self, url: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"url", url)
    }

    /// Expected volume ID (regular expression) for ISO9660 image/device.
    #[doc(alias = "volume-id")]
    fn set_volume_id(&self, volume_id: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"volume-id", volume_id)
    }

    /// Expected volume size, in bytes for ISO9660 image/device.
    #[doc(alias = "volume-size")]
    fn set_volume_size(&self, volume_size: i64) {
        ObjectExt::set_property(self.as_ref(),"volume-size", volume_size)
    }

    #[doc(alias = "application-id")]
    fn connect_application_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_application_id_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::application-id".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_application_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "architecture")]
    fn connect_architecture_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_architecture_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::architecture".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_architecture_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "eject-after-install")]
    fn connect_eject_after_install_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_eject_after_install_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::eject-after-install".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_eject_after_install_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "initrd-path")]
    fn connect_initrd_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_initrd_path_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::initrd-path".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_initrd_path_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "installer")]
    fn connect_installer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_installer_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::installer".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_installer_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "installer-reboots")]
    fn connect_installer_reboots_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_installer_reboots_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::installer-reboots".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_installer_reboots_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "installer-script")]
    fn connect_installer_script_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_installer_script_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::installer-script".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_installer_script_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "kernel-path")]
    fn connect_kernel_path_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_kernel_path_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::kernel-path".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_kernel_path_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "languages")]
    fn connect_languages_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_languages_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::languages".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_languages_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "live")]
    fn connect_live_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_live_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::live".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_live_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "os")]
    fn connect_os_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_os_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::os".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_os_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "publisher-id")]
    fn connect_publisher_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_publisher_id_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::publisher-id".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_publisher_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "system-id")]
    fn connect_system_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_system_id_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::system-id".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_system_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "url")]
    fn connect_url_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_url_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::url".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_url_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "volume-id")]
    fn connect_volume_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_volume_id_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::volume-id".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_volume_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "volume-size")]
    fn connect_volume_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_volume_size_trampoline<P: IsA<Media>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoMedia, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Media::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::volume-size".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_volume_size_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Media>> MediaExt for O {}
