// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../girs
// DO NOT EDIT

use crate::{ffi,Entity,ProductList,ProductRelationship};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    ///
    ///
    /// This is an Abstract Base Class, you cannot instantiate it.
    ///
    /// ## Properties
    ///
    ///
    /// #### `codename`
    ///  The codename of this product.
    ///
    /// Readable
    ///
    ///
    /// #### `logo`
    ///  The URI of the logo of the product.
    ///
    /// Readable
    ///
    ///
    /// #### `name`
    ///  The name of this product.
    ///
    /// Readable
    ///
    ///
    /// #### `short-id`
    ///  The short ID of this product.
    ///
    /// Readable
    ///
    ///
    /// #### `vendor`
    ///  The Vendor of this product.
    ///
    /// Readable
    ///
    ///
    /// #### `version`
    ///  The version of the product.
    ///
    /// Readable
    /// <details><summary><h4>Entity</h4></summary>
    ///
    ///
    /// #### `id`
    ///  The unique identifier for the entity The format of identifiers
    /// is undefined, but the recommended practice is to use a URI.
    /// This parameter must be set at time of construction as no
    /// default value is provided.
    ///
    /// Readable | Writeable | Construct
    /// </details>
    ///
    /// # Implements
    ///
    /// [`ProductExt`][trait@crate::prelude::ProductExt], [`EntityExt`][trait@crate::prelude::EntityExt]
    #[doc(alias = "OsinfoProduct")]
    pub struct Product(Object<ffi::OsinfoProduct, ffi::OsinfoProductClass>) @extends Entity;

    match fn {
        type_ => || ffi::osinfo_product_get_type(),
    }
}

impl Product {
        pub const NONE: Option<&'static Product> = None;
    
}

/// Trait containing all [`struct@Product`] methods.
///
/// # Implementors
///
/// [`Os`][struct@crate::Os], [`Platform`][struct@crate::Platform], [`Product`][struct@crate::Product]
pub trait ProductExt: IsA<Product> + 'static {
    /// Add an association between two products
    /// ## `relshp`
    /// the relationship
    /// ## `otherproduct`
    /// the product to relate to
    #[doc(alias = "osinfo_product_add_related")]
    fn add_related(&self, relshp: ProductRelationship, otherproduct: &impl IsA<Product>) {
        unsafe {
            ffi::osinfo_product_add_related(self.as_ref().to_glib_none().0, relshp.into_glib(), otherproduct.as_ref().to_glib_none().0);
        }
    }

    ///
    /// # Returns
    ///
    /// The product's codename, or NULL.
    #[doc(alias = "osinfo_product_get_codename")]
    #[doc(alias = "get_codename")]
    fn codename(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_product_get_codename(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// A [`glib::Date`][crate::glib::Date] representing the product's EOL date,
    ///  or NULL.
    #[doc(alias = "osinfo_product_get_eol_date")]
    #[doc(alias = "get_eol_date")]
    fn eol_date(&self) -> Option<glib::Date> {
        unsafe {
            from_glib_full(ffi::osinfo_product_get_eol_date(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// A string representing the product's EOL date, or NULL.
    #[doc(alias = "osinfo_product_get_eol_date_string")]
    #[doc(alias = "get_eol_date_string")]
    fn eol_date_string(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_product_get_eol_date_string(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "osinfo_product_get_logo")]
    #[doc(alias = "get_logo")]
    fn logo(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_product_get_logo(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "osinfo_product_get_name")]
    #[doc(alias = "get_name")]
    fn name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_product_get_name(self.as_ref().to_glib_none().0))
        }
    }

    /// Get a list of products satisfying the requested
    /// relationship
    /// ## `relshp`
    /// the relationship to query
    ///
    /// # Returns
    ///
    /// a list of related products
    #[doc(alias = "osinfo_product_get_related")]
    #[doc(alias = "get_related")]
    fn related(&self, relshp: ProductRelationship) -> Option<ProductList> {
        unsafe {
            from_glib_full(ffi::osinfo_product_get_related(self.as_ref().to_glib_none().0, relshp.into_glib()))
        }
    }

    ///
    /// # Returns
    ///
    /// A [`glib::Date`][crate::glib::Date] representing the product's release date,
    ///  or NULL.
    #[doc(alias = "osinfo_product_get_release_date")]
    #[doc(alias = "get_release_date")]
    fn release_date(&self) -> Option<glib::Date> {
        unsafe {
            from_glib_full(ffi::osinfo_product_get_release_date(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// A string representing the product's release date, or NULL.
    #[doc(alias = "osinfo_product_get_release_date_string")]
    #[doc(alias = "get_release_date_string")]
    fn release_date_string(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_product_get_release_date_string(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "osinfo_product_get_short_id")]
    #[doc(alias = "get_short_id")]
    #[doc(alias = "short-id")]
    fn short_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_product_get_short_id(self.as_ref().to_glib_none().0))
        }
    }

    /// Retrieve all the short-ids associated with the product.
    ///
    /// # Returns
    ///
    /// the list of short-ids.
    #[cfg(feature = "v1_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_5")))]
    #[doc(alias = "osinfo_product_get_short_id_list")]
    #[doc(alias = "get_short_id_list")]
    fn short_id_list(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::osinfo_product_get_short_id_list(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "osinfo_product_get_vendor")]
    #[doc(alias = "get_vendor")]
    fn vendor(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_product_get_vendor(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "osinfo_product_get_version")]
    #[doc(alias = "get_version")]
    fn version(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::osinfo_product_get_version(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "codename")]
    fn connect_codename_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_codename_trampoline<P: IsA<Product>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoProduct, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Product::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::codename".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_codename_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "logo")]
    fn connect_logo_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_logo_trampoline<P: IsA<Product>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoProduct, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Product::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::logo".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_logo_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "name")]
    fn connect_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_name_trampoline<P: IsA<Product>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoProduct, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Product::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "short-id")]
    fn connect_short_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_short_id_trampoline<P: IsA<Product>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoProduct, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Product::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::short-id".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_short_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "vendor")]
    fn connect_vendor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_vendor_trampoline<P: IsA<Product>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoProduct, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Product::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::vendor".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_vendor_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "version")]
    fn connect_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_version_trampoline<P: IsA<Product>, F: Fn(&P) + 'static>(this: *mut ffi::OsinfoProduct, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) { unsafe {
            let f: &F = &*(f as *const F);
            f(Product::from_glib_borrow(this).unsafe_cast_ref())
        }}
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::version".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_version_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Product>> ProductExt for O {}
