// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../girs
// DO NOT EDIT
#![allow(deprecated)]

use crate::{ffi,Datamap,DatamapList,Deployment,DeploymentList,Device,DeviceList,InstallScript,InstallScriptList,Media,Os,OsList,Platform,PlatformList,ProductRelationship,Tree};
#[cfg(feature = "v1_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
use crate::{MediaList,TreeList};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    ///
    ///
    /// # Implements
    ///
    /// [`DbExt`][trait@crate::prelude::DbExt]
    #[doc(alias = "OsinfoDb")]
    pub struct Db(Object<ffi::OsinfoDb, ffi::OsinfoDbClass>);

    match fn {
        type_ => || ffi::osinfo_db_get_type(),
    }
}

impl Db {
        pub const NONE: Option<&'static Db> = None;
    

    ///
    /// # Returns
    ///
    /// the new database
    #[doc(alias = "osinfo_db_new")]
    pub fn new() -> Db {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::osinfo_db_new())
        }
    }
}

impl Default for Db {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

/// Trait containing all [`struct@Db`] methods.
///
/// # Implementors
///
/// [`Db`][struct@crate::Db]
pub trait DbExt: IsA<Db> + 'static {
    /// ## `datamap`
    /// an install datamap
    #[doc(alias = "osinfo_db_add_datamap")]
    fn add_datamap(&self, datamap: &impl IsA<Datamap>) {
        unsafe {
            ffi::osinfo_db_add_datamap(self.as_ref().to_glib_none().0, datamap.as_ref().to_glib_none().0);
        }
    }

    /// ## `deployment`
    /// a deployment
    #[doc(alias = "osinfo_db_add_deployment")]
    fn add_deployment(&self, deployment: &impl IsA<Deployment>) {
        unsafe {
            ffi::osinfo_db_add_deployment(self.as_ref().to_glib_none().0, deployment.as_ref().to_glib_none().0);
        }
    }

    /// ## `device`
    /// a device
    #[doc(alias = "osinfo_db_add_device")]
    fn add_device(&self, device: &impl IsA<Device>) {
        unsafe {
            ffi::osinfo_db_add_device(self.as_ref().to_glib_none().0, device.as_ref().to_glib_none().0);
        }
    }

    /// ## `script`
    /// an install script
    #[doc(alias = "osinfo_db_add_install_script")]
    fn add_install_script(&self, script: &impl IsA<InstallScript>) {
        unsafe {
            ffi::osinfo_db_add_install_script(self.as_ref().to_glib_none().0, script.as_ref().to_glib_none().0);
        }
    }

    /// ## `os`
    /// an operating system
    #[doc(alias = "osinfo_db_add_os")]
    fn add_os(&self, os: &impl IsA<Os>) {
        unsafe {
            ffi::osinfo_db_add_os(self.as_ref().to_glib_none().0, os.as_ref().to_glib_none().0);
        }
    }

    /// ## `platform`
    /// an platform
    #[doc(alias = "osinfo_db_add_platform")]
    fn add_platform(&self, platform: &impl IsA<Platform>) {
        unsafe {
            ffi::osinfo_db_add_platform(self.as_ref().to_glib_none().0, platform.as_ref().to_glib_none().0);
        }
    }

    /// Find the deployment for `os` on `platform`, if any.
    /// ## `os`
    /// the operating system to find
    /// ## `platform`
    /// the virtualization platform
    ///
    /// # Returns
    ///
    /// the deployment, or NULL
    #[doc(alias = "osinfo_db_find_deployment")]
    fn find_deployment(&self, os: &impl IsA<Os>, platform: &impl IsA<Platform>) -> Option<Deployment> {
        unsafe {
            from_glib_none(ffi::osinfo_db_find_deployment(self.as_ref().to_glib_none().0, os.as_ref().to_glib_none().0, platform.as_ref().to_glib_none().0))
        }
    }

    /// ## `id`
    /// the unique operating system identifier
    ///
    /// # Returns
    ///
    /// the install datamap, or NULL if none is found
    #[doc(alias = "osinfo_db_get_datamap")]
    #[doc(alias = "get_datamap")]
    fn datamap(&self, id: &str) -> Option<Datamap> {
        unsafe {
            from_glib_none(ffi::osinfo_db_get_datamap(self.as_ref().to_glib_none().0, id.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the list of install datamaps
    #[doc(alias = "osinfo_db_get_datamap_list")]
    #[doc(alias = "get_datamap_list")]
    fn datamap_list(&self) -> Option<DatamapList> {
        unsafe {
            from_glib_full(ffi::osinfo_db_get_datamap_list(self.as_ref().to_glib_none().0))
        }
    }

    /// ## `id`
    /// the unique operating system identifier
    ///
    /// # Returns
    ///
    /// the operating system, or NULL if none is found
    #[doc(alias = "osinfo_db_get_deployment")]
    #[doc(alias = "get_deployment")]
    fn deployment(&self, id: &str) -> Option<Deployment> {
        unsafe {
            from_glib_none(ffi::osinfo_db_get_deployment(self.as_ref().to_glib_none().0, id.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the list of deployments
    #[doc(alias = "osinfo_db_get_deployment_list")]
    #[doc(alias = "get_deployment_list")]
    fn deployment_list(&self) -> Option<DeploymentList> {
        unsafe {
            from_glib_full(ffi::osinfo_db_get_deployment_list(self.as_ref().to_glib_none().0))
        }
    }

    /// ## `id`
    /// the unique device identifier
    ///
    /// # Returns
    ///
    /// the device, or NULL if none is found
    #[doc(alias = "osinfo_db_get_device")]
    #[doc(alias = "get_device")]
    fn device(&self, id: &str) -> Option<Device> {
        unsafe {
            from_glib_none(ffi::osinfo_db_get_device(self.as_ref().to_glib_none().0, id.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the list of devices
    #[doc(alias = "osinfo_db_get_device_list")]
    #[doc(alias = "get_device_list")]
    fn device_list(&self) -> Option<DeviceList> {
        unsafe {
            from_glib_full(ffi::osinfo_db_get_device_list(self.as_ref().to_glib_none().0))
        }
    }

    /// ## `id`
    /// the unique operating system identifier
    ///
    /// # Returns
    ///
    /// the install script, or NULL if none is found
    #[doc(alias = "osinfo_db_get_install_script")]
    #[doc(alias = "get_install_script")]
    fn install_script(&self, id: &str) -> Option<InstallScript> {
        unsafe {
            from_glib_none(ffi::osinfo_db_get_install_script(self.as_ref().to_glib_none().0, id.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the list of install scripts
    #[doc(alias = "osinfo_db_get_install_script_list")]
    #[doc(alias = "get_install_script_list")]
    fn install_script_list(&self) -> Option<InstallScriptList> {
        unsafe {
            from_glib_full(ffi::osinfo_db_get_install_script_list(self.as_ref().to_glib_none().0))
        }
    }

    /// ## `id`
    /// the unique operating system identifier
    ///
    /// # Returns
    ///
    /// the operating system, or NULL if none is found
    #[doc(alias = "osinfo_db_get_os")]
    #[doc(alias = "get_os")]
    fn os(&self, id: &str) -> Option<Os> {
        unsafe {
            from_glib_none(ffi::osinfo_db_get_os(self.as_ref().to_glib_none().0, id.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the list of operating systems
    #[doc(alias = "osinfo_db_get_os_list")]
    #[doc(alias = "get_os_list")]
    fn os_list(&self) -> Option<OsList> {
        unsafe {
            from_glib_full(ffi::osinfo_db_get_os_list(self.as_ref().to_glib_none().0))
        }
    }

    /// ## `id`
    /// the unique platform identifier
    ///
    /// # Returns
    ///
    /// the platform, or NULL if none is found
    #[doc(alias = "osinfo_db_get_platform")]
    #[doc(alias = "get_platform")]
    fn platform(&self, id: &str) -> Option<Platform> {
        unsafe {
            from_glib_none(ffi::osinfo_db_get_platform(self.as_ref().to_glib_none().0, id.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// the list of platforms
    #[doc(alias = "osinfo_db_get_platform_list")]
    #[doc(alias = "get_platform_list")]
    fn platform_list(&self) -> Option<PlatformList> {
        unsafe {
            from_glib_full(ffi::osinfo_db_get_platform_list(self.as_ref().to_glib_none().0))
        }
    }

    /// Guess operating system given an [`Tree`][crate::Tree] object.
    ///
    /// # Deprecated since 1.6
    ///
    /// Use [`identify_tree()`][Self::identify_tree()] instead.
    /// ## `tree`
    /// the installation tree
    ///
    /// # Returns
    ///
    /// the operating system, or NULL if guessing failed
    ///
    /// ## `matched_tree`
    /// the matched operating
    /// system tree
    #[cfg_attr(feature = "v1_6", deprecated = "Since 1.6")]
    #[allow(deprecated)]
    #[doc(alias = "osinfo_db_guess_os_from_tree")]
    fn guess_os_from_tree(&self, tree: &impl IsA<Tree>) -> (Os, Tree) {
        unsafe {
            let mut matched_tree = std::ptr::null_mut();
            let ret = from_glib_none(ffi::osinfo_db_guess_os_from_tree(self.as_ref().to_glib_none().0, tree.as_ref().to_glib_none().0, &mut matched_tree));
            (ret, from_glib_none(matched_tree))
        }
    }

    /// Try to match a newly created `media` with a media description from `self`.
    /// If found, `media` will be filled with the corresponding information
    /// stored in `self`. In particular, after a call to [`identify_media()`][Self::identify_media()], if
    /// the media could be identified, its OsinfoEntify::id and OsinfoMedia::os
    /// properties will be set.
    ///
    /// The match for `media` in `self` is not guaranteed to be unique and
    /// this method will only return the first match found. The order
    /// in which matches are identified is not guaranteed, so when there
    /// are multiple matches, the returned match may vary over time.
    /// Applications are recommended to use the `osinfo_db_identify_all_media`
    /// method instead to receive all matched media.
    /// ## `media`
    /// the installation media
    /// data
    ///
    /// # Returns
    ///
    /// TRUE if `media` was found in `self`, FALSE otherwise
    #[doc(alias = "osinfo_db_identify_media")]
    fn identify_media(&self, media: &impl IsA<Media>) -> bool {
        unsafe {
            from_glib(ffi::osinfo_db_identify_media(self.as_ref().to_glib_none().0, media.as_ref().to_glib_none().0))
        }
    }

    /// Try to match a newly created `media` with a media description from `self`.
    /// The return list will contain any [`Media`][crate::Media] instances from `self` that
    /// matched `media`. Usuaully there will only be one match returned, but
    /// applications should be prepared to deal with multiple matches. The
    /// returned [`Media`][crate::Media] instances will have their OsinfoEntify::id and
    /// OsinfoMedia::os properties will be set, while `media` is left unmodified.
    /// ## `media`
    /// the installation media data
    ///
    /// # Returns
    ///
    /// a list containing any matches for `media` found in `self`
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    #[doc(alias = "osinfo_db_identify_medialist")]
    fn identify_medialist(&self, media: &impl IsA<Media>) -> Option<MediaList> {
        unsafe {
            from_glib_full(ffi::osinfo_db_identify_medialist(self.as_ref().to_glib_none().0, media.as_ref().to_glib_none().0))
        }
    }

    /// Try to match a newly created `tree` with a tree description from `self`.
    /// If found, `tree` will be filled with the corresponding information
    /// stored in `self`. In particular, after a call to [`identify_tree()`][Self::identify_tree()], if
    /// the tree could be identified, its OsinfoEntify::id and OsinfoMedia::os
    /// properties will be set.
    ///
    /// The match for `tree` in `self` is not guaranteed to be unique and
    /// this method will only return the first match found. The order
    /// in which matches are identified is not guaranteed, so when there
    /// are multiple matches, the returned match may vary over time.
    /// Applications are recommended to use the `osinfo_db_identify_all_tree`
    /// method instead to receive all matched tree.
    /// ## `tree`
    /// the installation tree
    /// data
    ///
    /// # Returns
    ///
    /// TRUE if `tree` was found in `self`, FALSE otherwise
    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "osinfo_db_identify_tree")]
    fn identify_tree(&self, tree: &impl IsA<Tree>) -> bool {
        unsafe {
            from_glib(ffi::osinfo_db_identify_tree(self.as_ref().to_glib_none().0, tree.as_ref().to_glib_none().0))
        }
    }

    /// Try to match a newly created `tree` with a tree description from `self`.
    /// The return list will contain any [`Tree`][crate::Tree] instances from `self` that
    /// matched `tree`. Usuaully there will only be one match returned, but
    /// applications should be prepared to deal with multiple matches. The
    /// returned [`Tree`][crate::Tree] instances will have their OsinfoEntify::id and
    /// OsinfoTree::os properties will be set, while `tree` is left unmodified.
    /// ## `tree`
    /// the installation tree data
    ///
    /// # Returns
    ///
    /// a list containing any matches for `tree` found in `self`
    #[cfg(feature = "v1_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_10")))]
    #[doc(alias = "osinfo_db_identify_treelist")]
    fn identify_treelist(&self, tree: &impl IsA<Tree>) -> Option<TreeList> {
        unsafe {
            from_glib_full(ffi::osinfo_db_identify_treelist(self.as_ref().to_glib_none().0, tree.as_ref().to_glib_none().0))
        }
    }

    /// Get all operating systems that are the referee
    /// in an operating system relationship.
    /// ## `relshp`
    /// the product relationship
    ///
    /// # Returns
    ///
    /// a list of operating systems
    #[doc(alias = "osinfo_db_unique_values_for_os_relationship")]
    fn unique_values_for_os_relationship(&self, relshp: ProductRelationship) -> Option<OsList> {
        unsafe {
            from_glib_full(ffi::osinfo_db_unique_values_for_os_relationship(self.as_ref().to_glib_none().0, relshp.into_glib()))
        }
    }

    /// Get all platforms that are the referee
    /// in an platform relationship.
    /// ## `relshp`
    /// the product relationship
    ///
    /// # Returns
    ///
    /// a list of virtualization platforms
    #[doc(alias = "osinfo_db_unique_values_for_platform_relationship")]
    fn unique_values_for_platform_relationship(&self, relshp: ProductRelationship) -> Option<PlatformList> {
        unsafe {
            from_glib_full(ffi::osinfo_db_unique_values_for_platform_relationship(self.as_ref().to_glib_none().0, relshp.into_glib()))
        }
    }

    /// Get all unique values for a named property amongst all
    /// deployments in the database
    /// ## `prop_name`
    /// a property name
    ///
    /// # Returns
    ///
    /// a list of strings
    #[doc(alias = "osinfo_db_unique_values_for_property_in_deployment")]
    fn unique_values_for_property_in_deployment(&self, prop_name: &str) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::osinfo_db_unique_values_for_property_in_deployment(self.as_ref().to_glib_none().0, prop_name.to_glib_none().0))
        }
    }

    /// Get all unique values for a named property amongst all
    /// devices in the database
    /// ## `prop_name`
    /// a property name
    ///
    /// # Returns
    ///
    /// a list of strings
    #[doc(alias = "osinfo_db_unique_values_for_property_in_device")]
    fn unique_values_for_property_in_device(&self, prop_name: &str) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::osinfo_db_unique_values_for_property_in_device(self.as_ref().to_glib_none().0, prop_name.to_glib_none().0))
        }
    }

    /// Get all unique values for a named property amongst all
    /// operating systems in the database
    /// ## `prop_name`
    /// a property name
    ///
    /// # Returns
    ///
    /// a list of strings
    #[doc(alias = "osinfo_db_unique_values_for_property_in_os")]
    fn unique_values_for_property_in_os(&self, prop_name: &str) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::osinfo_db_unique_values_for_property_in_os(self.as_ref().to_glib_none().0, prop_name.to_glib_none().0))
        }
    }

    /// Get all unique values for a named property amongst all
    /// platforms in the database
    /// ## `prop_name`
    /// a property name
    ///
    /// # Returns
    ///
    /// a list of strings
    #[doc(alias = "osinfo_db_unique_values_for_property_in_platform")]
    fn unique_values_for_property_in_platform(&self, prop_name: &str) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::osinfo_db_unique_values_for_property_in_platform(self.as_ref().to_glib_none().0, prop_name.to_glib_none().0))
        }
    }
}

impl<O: IsA<Db>> DbExt for O {}
